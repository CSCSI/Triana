<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_04) on Wed Sep 05 14:31:38 BST 2012 -->
<title>ComplexSpectrum</title>
<meta name="date" content="2012-09-05">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ComplexSpectrum";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../triana/types/ComplexSampleSet.html" title="class in triana.types"><span class="strong">Prev Class</span></a></li>
<li><a href="../../triana/types/Const.html" title="class in triana.types"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?triana/types/ComplexSpectrum.html" target="_top">Frames</a></li>
<li><a href="ComplexSpectrum.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">triana.types</div>
<h2 title="Class ComplexSpectrum" class="title">Class ComplexSpectrum</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="../../triana/types/TrianaType.html" title="class in triana.types">triana.types.TrianaType</a></li>
<li>
<ul class="inheritance">
<li><a href="../../triana/types/GraphType.html" title="class in triana.types">triana.types.GraphType</a></li>
<li>
<ul class="inheritance">
<li><a href="../../triana/types/VectorType.html" title="class in triana.types">triana.types.VectorType</a></li>
<li>
<ul class="inheritance">
<li>triana.types.ComplexSpectrum</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.io.Serializable, <a href="../../triana/types/Arithmetic.html" title="interface in triana.types">Arithmetic</a>, <a href="../../triana/types/AsciiComm.html" title="interface in triana.types">AsciiComm</a>, <a href="../../triana/types/SequenceInterface.html" title="interface in triana.types">SequenceInterface</a>, <a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="strong">ComplexSpectrum</span>
extends <a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a>
implements <a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a>, <a href="../../triana/types/AsciiComm.html" title="interface in triana.types">AsciiComm</a></pre>
<div class="block">ComplexSpectrum stores a one-dimensional array of double-precision complex numbers representing a complex Fourier
 spectrum. It includes a Triplet giving the integer values of the index of this array, and five new parameters: a
 double <i>resolution</i> giving the frequency resolution; a double <i>highestFrequency</i> giving the value of the
 largest frequency represented in the data set; an int <i>nFull</i> giving the number of points in the original data
 set from which the data here were derived (used if the data have been reduced to one-sided or narrow-band spectra);
 and two boolean flags, (i) a flag <i>twoSided</i> that says whether the ComplexSpectrum is one-sided or two-sided,
 and (ii) a flag <i>narrow</i> that says whether the data are a narrow bandwidth derived from a larger full-bandwidth
 spectrum. ComplexSpectrum is the basic Triana class for holding one-dimensional Fourier tranforms. It is derived from
 the VectorType class and implements the Spectral interface. </p><p> ComplexSpectrum implements the Triana model for
 storing spectral data. The model is general enough to contain a multi-dimensional Fourier transform derived from a
 complex data set containing an arbitrary number of points. It is complete enough to ensure that inverse Fourier
 transforms can be done correctly automatically, even if the data set is a narrow-band spectrum extracted from a full
 spectrum that obeys the Triana model. For two-sided spectra, the Triana storage model the same as that required by
 the Triana FFT unit and is one of the standard FFT storage models.  For one-sided data it is not quite the same as
 the close packing that is used by most Fast Fourier Transform (FFT) methods, so the Triana FFT unit converts from the
 Triana storage model to its own internal format. The Triana model is described fully here. First we deal with
 two-sided complete spectra, then one-sided. At the end we describe the way narrow bands are handled. The various
 descriptions assume a one-dimensional data set (one independent variable), but they apply to each dimension of
 multi-dimensional sets. </p><p> All spectral representations assume that the frequency values are uniformly spaced
 and are represented by an integer index <i>k</i>. The value of <i>resolution</i> is the (positive) difference between
 the frequencies associated with consecutive values of <i>k</i>. The index <i>k</i> is non-negative. </p><p> A
 two-sided ComplexSpectrum contains spectral values at both negative and positive frequencies. Values at non-negative
 frequencies are stored in the first part of the data vector in order of increasing frequency, and values at negative
 frequencies are stored in the second part, again in order of increasing frequency. The details depend on whether the
 total length of the spectral data set, <i>N</i>, is even or odd. </p><p> Two-sided, full-bandwidth spectra of even
 length <i>N</i> (<i>nFull</i> = <i>N</i> even, <i>narrow</i> = <i>false</i>, <i>twoSided</i> = <i>true</i>):<br> The
 frequency corresponding to the index <i>k</i> contained in the interval [0, <i>N</i>/2-1] is <i>k</i> *
 <i>resolution</i>; the frequency corresponding to index <i>k</i> in [<i>N</i>/2, <i>N</i>-1] is (<i>k</i> - <i>N</i>)
 * <i>resolution</i>. Thus, the highest absolute value of the frequency is associated with <i>k</i> = <i>N</i>/2. This
 frequency is -(<i>N</i>/2) * <i>resolution</i>, and it is called the Nyquist frequency. It should be equal to
 -<i>highestFrequency</i>. This is a consistency check. For even <i>N</i>, the spectral amplitude at this largest
 negative frequency is the same as that which could be associated with the largest positive frequency, +(<i>N</i>/2) *
 <i>resolution</i>. If this spectrum was or could have been derived as a Fourier transform of a real data set, then
 the data values associated with <i>k</i> = 0 and <i>k</i> = <i>N</i>/2 are real, and the data values at indices
 <i>k</i> and <i>N</i>-<i>k</i> are complex-conjugates of one another. Such a spectrum can be converted to a one-sided
 representation without the loss of information. </p><p> Two-sided, full-bandwidth spectra of odd length <i>N</i>
 (<i>nFull</i> = <i>N</i> odd, <i>narrow</i> = <i>false</i>, <i>twoSided</i> = <i>true</i>):<br> The frequency
 corresponding to the index <i>k</i> contained in the interval [0, (<i>N</i>-1)/2] is <i>k</i> * <i>resolution</i>;
 the frequency corresponding to index <i>k</i> in [(<i>N</i>+1)/2, <i>N</i>-1] is (<i>k</i> - <i>N</i>) *
 <i>resolution</i>. Thus, the highest positive frequency is associated with <i>k</i> = (<i>N</i>-1)/2; the lowest
 negative frequency with <i>k</i> = (<i>N</i>+1)/2; both these frequencies have absolute value (<i>N</i>-1)/2 *
 <i>resolution</i>; and this is called the Nyquist frequency. This should equal <i>highestFrequency</i> (this is a
 consistency check). The spectral amplitudes at the lowest and highest-frequency points are generally different when
 <i>N</i> is odd. If this spectrum was or could have been derived as a Fourier transform of a real data set, then the
 data value associated with <i>k</i> = 0 is real, and the data values at indices <i>k</i> and <i>N</i>-<i>k</i> are
 complex-conjugates of one another. Such a spectrum can be converted to a one-sided representation without the loss of
 information. </p><p> A one-sided ComplexSpectrum includes only non-negative frequencies. The data model contains
 enough information to perform an inverse Fourier transform on the spectrum on the assumption that the resulting data
 set will contain only real values. Thus, values at the negative frequencies that are not represented in the data set
 will be assumed to be the complex conjugates of the values at the corresponding positive frequencies. Details depend
 on whether the total number of data points in the corresponding two-sided spectrum was even or odd. For transforms of
 real data, one-sided representations are preferable because they require only about half the memory of two-sided
 representations, and they nevertheless contain the same information. </p><p> One-sided, full-bandwidth spectra of
 length <i>N</i> derived from a two-sided spectrum with an even number of elements (<i>nFull</i> even, <i>narrow</i> =
 <i>false</i>, <i>twoSided</i> = <i>false</i>):<br> In a one-sided spectrum containing <i>N</i> data points, the
 frequency corresponding to element <i>k</i> contained in [0, <i>N</i>-1] is <i>k</i> * <i>resolution</i>. The highest
 such frequency is (<i>N</i>-1) * <i>resolution</i>, and this should be equal to <i>highestFrequency</i>. This is a
 consistency check. Since the orginal time-series is assumed to be real, the element at <i>k</i> = 0 should be real.
 For this case, where <i>nFull</i> is even, the original spectrum (or time-series) must have contained 2*<i>N</i>-2
 points. This should be the value of <i>nFull</i>, and this is a further consistency check. The highest-frequency
 element of the current data set (index <i>N</i>-1) contains the value of the original spectrum at its highest
 frequency (index <i>N</i>-1 in that set), and this should be real as well. Thus a two-sided full-bandwidth spectrum
 derived from real data of length <i>nFull</i> = 2*<i>N</i>-2 can be converted to a one-sided spectrum just by
 extracting the first <i>N</i> elements.  Since the first and last of these elements are real, this extracted set
 contains 2*<i>N</i>-2 independent numbers. This storage model differs from those used by some FFT methods, typically
 because in those methods the two real elements are combined into a single complex storage location, saving one
 complex storage element. The storage saving is small and it would make manipulating spectra in Triana (such as adding
 or graphing them) clumsy, so it is not implemented. FFT units in Triana must perform any requisite conversions to
 their internal storage model themselves. </p><p> One-sided, full-bandwidth spectra of length <i>N</i> derived from a
 two-sided spectrum with an odd number of elements (<i>nFull</i> odd, <i>narrow</i> = <i>false</i>, <i>twoSided</i> =
 <i>false</i>):<br> In a one-sided spectrum containing <i>N</i> data points, the frequency corresponding to element
 <i>k</i> contained in [0, <i>N</i>-1] is <i>k</i> * <i>resolution</i>. The highest such frequency is (<i>N</i>-1) *
 <i>resolution</i>, and this should be equal to <i>highestFrequency</i>. This is a consistency check. Since the
 orginal time-series is assumed to be real, the element at <i>k</i> = 0 should be real. For this case, where
 <i>nFull</i> is odd, the original spectrum (or time-series) must have contained 2*<i>N</i> - 1 points. This should be
 the value of <i>nFull</i>, and this is a further consistency check. The highest-frequency element of the current data
 set (index <i>N</i>-1) contains the value of the original spectrum at its highest frequency (index <i>N</i>-1 in that
 set), and this will in general be complex. Thus a two-sided full-bandwidth spectrum derived from real data of length
 <i>nFull</i> = 2*<i>N</i>-1 can be converted to a one-sided spectrum just by extracting the first <i>N</i> elements.
 Since the first of these elements is real, this extracted set contains 2*<i>N</i>-1 independent numbers. The remarks
 in the previous paragraph about the data storage model for FFT methods apply here as well. </p><p> The Triana
 spectral data model allows for the bandwidth of the data to be narrower than that of the set from which it was
 derived, and the parameter <i>highestFrequency</i> is included in this class mainly to indicate the value of the
 upper edge of the frequency band. The lower edge can be deduced from the other data, such as the number of points and
 <i>resolution</i>. The Triana data storage model for narrow-band spectra places certain restrictions on the way such
 spectra can be constructed, so as to preserve as much as possible of the information needed to invert the spectrum
 back to a time-series. The information enables one to convert the data back to a full-bandwidth spectrum by padding
 with zeros. </p><p> Two-sided, narrow-band spectra of length <i>N</i> derived from a two-sided spectrum with an even
 number of elements (<i>nFull</i> even, <i>narrow</i> = <i>true</i>, <i>twoSided</i> = <i>true</i>):<br> Two-sided
 narrow-band data must always contain data points for related positive and negative frequencies. Removing the upper
 part of the spectrum requires removing the single highest-frequency value and then pairs of values for the contiguous
 frequencies (each pair being a frequency and its negative), i.e. removing in total an odd number of data points.
 Removing the lower part of the spectrum similarly requires removing an odd number of data points. Since the original
 data set had an even number of elements, we can determine the nature of the bandwidth of the narrow-band spectrum as
 follows. If <i>N</i> (actual number of elements) is even, then the band has been shrunk from both sides; the lower
 frequency limit is <i>highestFrequency</i> - (<i>N</i>/2 - 1) * <i>resolution</i> and should not be zero. The whole
 original frequency range can be reconstructed from these numbers and <i>nFull</i>. If <i>N</i> is odd, then either
 the highest original frequency or the lowest is still present in the band; if the highest is still present then
 <i>highestFrequency</i> = <i>nFull</i>/2 * <i>resolution</i>; if the lowest is still present then the lower frequency
 limit in this case, <i>highestFrequency</i> - ( (<i>N</i>-1)/2 ) * <i>resolution</i>, must be zero. A consistency
 test is that one of these conditions must hold if <i>N</i> is odd. </p><p> Two-sided, narrow-band spectra of length
 <i>N</i> derived from a two-sided spectrum with an odd number of elements (<i>nFull</i> odd, <i>narrow</i> =
 <i>true</i>, <i>twoSided</i> = <i>true</i>):<br> Two-sided narrow-band data must always contain data points for
 related positive and negative frequencies. Removing the lower part of the spectrum requires removing the single
 zero-frequency value and then pairs of values for the contiguous frequencies (each pair being a frequency and its
 negative), i.e. removing in total an odd number of data points. This will make <i>N</i> (the actual number of
 elements) even. Removing the upper part of the spectrum or a portion in the middle requires removing an even number
 of data points in frequency pairs. This will make <i>N</i> odd. Therefore, if <i>N</i> is even, the lower part of the
 spectrum has been removed, and the upper part may or may not have been removed. In this case, if
 <i>highestFrequency</i> = (<i>nFull</i>-1)/2 * <i>resolution</i>, then the upper part of the original band is still
 present. If <i>N</i> is odd, then the lower part of the spectrum is still present and the upper has been removed.
 </p><p> One-sided narrow-band spectra of length <i>N</i> derived from a two-sided spectrum with an even number of
 elements (<i>nFull</i> even, <i>narrow</i> = <i>true</i>, <i>twoSided</i> = <i>false</i>):<br> A one-sided spectrum
 is assumed derived from a two-sided spectrum that came from a Fourier transform of a real data set. This is then made
 narrow-band by removing frequencies at the lower and/or upper ends of the full band. If <i>highestFrequency</i> =
 <i>nFull</i>/2 * <i>resolution</i>, then the top of the band is still present, and (for consistency) the
 highest-frequency data value should be real. The lower frequency limit is <i>highestFrequency</i> - (<i>N</i>-1) *
 <i>resolution</i>, and this should be larger than zero. If the top of the band is missing, then one can calculate the
 lower frequency limit as above; if this is zero then the bottom of the band is still present, and the
 lowest-frequency data value should be real (consistency again). If the lower frequency limit is positive, then the
 bottom of the band is missing. These data are sufficient to reconstruct the two-sided narrow-band spectrum associated
 with this data set on the assumption that the inverse transform produces a real data set. </p><p> One-sided
 narrow-band spectra of length <i>N</i> derived from a two-sided spectrum with an odd number of elements (<i>nFull</i>
 odd, <i>narrow</i> = <i>true</i>, <i>twoSided</i> = <i>false</i>):<br> A one-sided spectrum is assumed derived from a
 two-sided spectrum that came from a Fourier transform of a real data set. This is then made narrow-band by removing
 frequencies at the lower and/or upper ends of the full band. If <i>highestFrequency</i> = (<i>nFull</i>-1)/2 *
 <i>resolution</i>, then the top of the band is still present, and (for consistency) the highest-frequency data value
 should be real. The lower frequency limit is <i>highestFrequency</i> - (<i>N</i>-1) * <i>resolution</i>, and this
 should be larger than zero. If the top of the band is missing, then one can calculate the lower frequency limit as
 above; if this is zero then the bottom of the band is still present, and the lowest-frequency data value should be
 real (consistency again). If the lower frequency limit is positive, then the bottom of the band is missing. These
 data are sufficient to reconstruct the two-sided narrow-band spectrum associated with this data set on the assumption
 that the inverse transform produces a real data set. </p><p> ComplexSpectrum contains a number of methods for
 accessing and modifying these parameters.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../triana/types/Spectral.html" title="interface in triana.types"><code>Spectral</code></a>, 
<a href="../../triana/types/SampleSet.html" title="class in triana.types"><code>SampleSet</code></a>, 
<a href="../../triana/types/Spectrum.html" title="class in triana.types"><code>Spectrum</code></a>, 
<a href="../../triana/types/GraphType.html" title="class in triana.types"><code>GraphType</code></a>, 
<a href="../../triana/types/util/Triplet.html" title="class in triana.types.util"><code>Triplet</code></a>, 
<a href="../../serialized-form.html#triana.types.ComplexSpectrum">Serialized Form</a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#frequencyResolution">frequencyResolution</a></strong></code>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#imag">imag</a></strong></code>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double[]</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#real">real</a></strong></code>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#samplingFrequency">samplingFrequency</a></strong></code>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="fields_inherited_from_class_triana.types.VectorType">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;triana.types.<a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></h3>
<code><a href="../../triana/types/VectorType.html#x">x</a>, <a href="../../triana/types/VectorType.html#xlabel">xlabel</a>, <a href="../../triana/types/VectorType.html#y">y</a>, <a href="../../triana/types/VectorType.html#ylabel">ylabel</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="fields_inherited_from_class_triana.types.TrianaType">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;triana.types.<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a></h3>
<code><a href="../../triana/types/TrianaType.html#NOT_CONNECTED">NOT_CONNECTED</a>, <a href="../../triana/types/TrianaType.html#NOT_READY">NOT_READY</a>, <a href="../../triana/types/TrianaType.html#OUT_OF_RANGE">OUT_OF_RANGE</a></code></li>
</ul>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/ComplexSpectrum.html#ComplexSpectrum()">ComplexSpectrum</a></strong>()</code>
<div class="block">Create and empty ComplexSpectrum with no parameters set.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../triana/types/ComplexSpectrum.html#ComplexSpectrum(boolean, boolean, double[], double[], int, double, double)">ComplexSpectrum</a></strong>(boolean&nbsp;ts,
               boolean&nbsp;nrw,
               double[]&nbsp;real,
               double[]&nbsp;imag,
               int&nbsp;nOrig,
               double&nbsp;df,
               double&nbsp;hf)</code>
<div class="block">Creates a new ComplexSpectrum with arguments giving the sidedness, whether it is narrow-band or broad-band, the
 data arrays, the number of points in the original broad-band spectrum, the frequency resolution, and the highest
 frequency in the current spectrum.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/ComplexSpectrum.html#ComplexSpectrum(boolean, boolean, int, int, double, double)">ComplexSpectrum</a></strong>(boolean&nbsp;ts,
               boolean&nbsp;nrw,
               int&nbsp;len,
               int&nbsp;nOrig,
               double&nbsp;df,
               double&nbsp;hf)</code>
<div class="block">Creates a new ComplexSpectrum with arguments giving the sidedness, whether it is narrow-band or broad-band, the
 data length, the number of points in the original broad-band spectrum, the frequency resolution, and the highest
 frequency in the current spectrum.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../triana/types/ComplexSpectrum.html#ComplexSpectrum(boolean, double[], double[], int, double)">ComplexSpectrum</a></strong>(boolean&nbsp;ts,
               double[]&nbsp;real,
               double[]&nbsp;imag,
               int&nbsp;nOrig,
               double&nbsp;df)</code>
<div class="block">Creates a new ComplexSpectrum with given sidedness, data arrays, number of points in the two-sided spectrum, and
 frequency resolution.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/ComplexSpectrum.html#ComplexSpectrum(boolean, int, double)">ComplexSpectrum</a></strong>(boolean&nbsp;ts,
               int&nbsp;nOrig,
               double&nbsp;df)</code>
<div class="block">Creates a new ComplexSpectrum with a given sidedness, number of points that there would be in the two-sided
 spectrum, and frequency resolution.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../triana/types/ComplexSpectrum.html#ComplexSpectrum(double, double[])">ComplexSpectrum</a></strong>(double&nbsp;samplingFrequency,
               double[]&nbsp;real)</code>
<div class="block">This is an obsolete Constructor that creates a new one-sided ComplexSpectrum with a certain sampling frequency
 and the actual allocated real data.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/ComplexSpectrum.html#ComplexSpectrum(double, double[], double[])">ComplexSpectrum</a></strong>(double&nbsp;samplingFrequency,
               double[]&nbsp;real,
               double[]&nbsp;imag)</code>
<div class="block">This is an obsolete Constructor that creates a new one-sided ComplexSpectrum with a certain sampling frequency
 and the actual allocated complex data.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../triana/types/ComplexSpectrum.html#ComplexSpectrum(double, int)">ComplexSpectrum</a></strong>(double&nbsp;sf,
               int&nbsp;points)</code>
<div class="block">This is an obsolete Constructor that will be eliminated when possible.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/ComplexSpectrum.html#ComplexSpectrum(triana.types.Spectrum)">ComplexSpectrum</a></strong>(<a href="../../triana/types/Spectrum.html" title="class in triana.types">Spectrum</a>&nbsp;s)</code>
<div class="block">Creates a ComplexSpectrum from a (real) Spectrum by setting the imaginary part of the data to zero.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../triana/types/ComplexSpectrum.html#ComplexSpectrum(triana.types.Spectrum, boolean)">ComplexSpectrum</a></strong>(<a href="../../triana/types/Spectrum.html" title="class in triana.types">Spectrum</a>&nbsp;s,
               boolean&nbsp;copy)</code>
<div class="block">Creates a ComplexSpectrum from a (real) Spectrum by setting the imaginary part of the data to zero.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a></code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#copyMe()">copyMe</a></strong>()</code>
<div class="block">This is one of the most important methods of Triana data.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#copyParameters(triana.types.TrianaType)">copyParameters</a></strong>(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;source)</code>
<div class="block">Copies modifiable parameters from the argument object to the current object.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#equals(triana.types.TrianaType)">equals</a></strong>(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;obj)</code>
<div class="block">Determines whether the argument TrianaType is equal to the current ComplexSpectrum.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#extendWithZeros(int, boolean)">extendWithZeros</a></strong>(int&nbsp;newLength,
               boolean&nbsp;front)</code>
<div class="block">Extends the data set to a longer set by padding with zeros, keeping the frequency resolution unchanged.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#frequencyResolution()">frequencyResolution</a></strong>()</code>
<div class="block">Obsolete method for obtaining frequency resolution.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getFrequencyArray(int)">getFrequencyArray</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the frequency values of the independent data points for the given dimension, in the order of lowest
 frequency to highest, regardless of how the data are stored internally.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getFrequencyResolution()">getFrequencyResolution</a></strong>()</code>
<div class="block">Returns the frequency resolution of the data.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getFrequencyResolution(int)">getFrequencyResolution</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the frequency resolution of the data for the given dimension (independent variable).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getGraphArrayImag(int)">getGraphArrayImag</a></strong>(int&nbsp;dv)</code>
<div class="block">Returns the imaginary part of the dependent variable ordered so that the frequency values all run monotonically
 upwards.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getGraphArrayReal(int)">getGraphArrayReal</a></strong>(int&nbsp;dv)</code>
<div class="block">Returns the real part of the dependent variable ordered so that the frequency values all run monotonically
 upwards.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double[]</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getIndependentScaleImag(int)">getIndependentScaleImag</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns null because the data is real.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getIndependentScaleReal(int)">getIndependentScaleReal</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the independent data scaled the way they should be graphed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getLowerFrequencyBound()">getLowerFrequencyBound</a></strong>()</code>
<div class="block">Returns the (non-negative) value of the lowest frequency in the frequency band held in the object.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getLowerFrequencyBound(int)">getLowerFrequencyBound</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the (non-negative) value of the lowest frequency in the frequency band held in the object, for the given
 dimension <i>dim</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getNyquist()">getNyquist</a></strong>()</code>
<div class="block">Returns the Nyquist frequency, defined to be the highest frequency that this data set could contain if it were
 not narrow-banded.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getOrderedSpectrumImag()">getOrderedSpectrumImag</a></strong>()</code>
<div class="block">Returns the imaginary parts of the values of the spectrum (data points) in a multidimensional array, ordered so
 that in each dimension the values correspond to frequencies running from the lowest to the highest, regardless of
 the internal data model.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getOrderedSpectrumReal()">getOrderedSpectrumReal</a></strong>()</code>
<div class="block">Returns the real parts of the values of the spectrum (data points) in a multidimensional array, ordered so that
 in each dimension the values correspond to frequencies running from the lowest to the highest, regardless of the
 internal data model.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getOriginalN()">getOriginalN</a></strong>()</code>
<div class="block">Returns the number of points in the data set whose transform could have led to the present data, or equivalently
 the number of points in the two-sided full-bandwidth spectrum from which the present spectrum could have been
 derived.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getOriginalN(int)">getOriginalN</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the number of points in the data set in the given dimension whose transform could have led to the present
 data, or equivalently the number of points in the two-sided full-bandwidth spectrum from which the present
 spectrum could have been derived.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getSamplingRate()">getSamplingRate</a></strong>()</code>
<div class="block">Returns the sampling frequency that a time-series would have had if it had led to the present spectral data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getUpperFrequencyBound()">getUpperFrequencyBound</a></strong>()</code>
<div class="block">Returns the (non-negative) value of the highest frequency in the frequency band held in the object.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#getUpperFrequencyBound(int)">getUpperFrequencyBound</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the (non-negative) value of the highest frequency in the frequency band held in the object, for the given
 dimension <i>dim</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#inputFromStream(java.io.BufferedReader)">inputFromStream</a></strong>(java.io.BufferedReader&nbsp;dis)</code>
<div class="block">Used when Triana types want to be able to receive ASCII data from the output of other programs.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#interpolateZeros(int, boolean)">interpolateZeros</a></strong>(int&nbsp;factor,
                boolean&nbsp;before)</code>
<div class="block">Inserts zeros in between existing elements of the data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#isCompatible(triana.types.TrianaType)">isCompatible</a></strong>(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;obj)</code>
<div class="block">Tests the argument object to determine if it makes sense to perform arithmetic operations between it and the
 current object.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#isNarrow()">isNarrow</a></strong>()</code>
<div class="block">Returns true if the data represent a narrow bandwidth derived from a full-band spectrum.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#isNarrow(int)">isNarrow</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns true if the data for the given dimension represent a narrow bandwidth derived from a full-band spectrum.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#isTwoSided()">isTwoSided</a></strong>()</code>
<div class="block">Returns <i>true</i> if the data are stored as a two-sided transform, i.e.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#outputToStream(java.io.PrintWriter)">outputToStream</a></strong>(java.io.PrintWriter&nbsp;dos)</code>
<div class="block">Used when Triana types want to be able to send ASCII data to other programs using strings.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#points()">points</a></strong>()</code>
<div class="block">Obsolete method for obtaining the number of data points.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../triana/types/ComplexSpectrum.html" title="class in triana.types">ComplexSpectrum</a></code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#reduceNyquist(triana.types.ComplexSpectrum, boolean)">reduceNyquist</a></strong>(<a href="../../triana/types/ComplexSpectrum.html" title="class in triana.types">ComplexSpectrum</a>&nbsp;inputNarrow,
             boolean&nbsp;allocMem)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#samplingFrequency()">samplingFrequency</a></strong>()</code>
<div class="block">Obsolete method for obtaining sampling frequency.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#setDefaultAxisLabelling()">setDefaultAxisLabelling</a></strong>()</code>
<div class="block">Added by I.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#setFrequencyResolution(double)">setFrequencyResolution</a></strong>(double&nbsp;df)</code>
<div class="block">Sets the frequency resolution of the data to the given value.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#setFrequencyResolution(double, int)">setFrequencyResolution</a></strong>(double&nbsp;df,
                      int&nbsp;dim)</code>
<div class="block">Sets the frequency resolution of the data for the given dimension to the given value.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#setNarrow(boolean)">setNarrow</a></strong>(boolean&nbsp;n)</code>
<div class="block">Sets the narrow-bandedness flag to the value of the argument.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#setNarrow(boolean, int)">setNarrow</a></strong>(boolean&nbsp;n,
         int&nbsp;dim)</code>
<div class="block">Sets the narrow-bandedness flag associated with the given dimension to the value of the argument.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#setOriginalN(int)">setOriginalN</a></strong>(int&nbsp;nOrig)</code>
<div class="block">Sets to the given argument the number of points in the data set whose transform could have led to the present
 data, or equivalently the number of points in the two-sided full-bandwidth spectrum from which the present
 spectrum could have been derived.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#setOriginalN(int, int)">setOriginalN</a></strong>(int&nbsp;nOrig,
            int&nbsp;dim)</code>
<div class="block">Sets to the given first argument <i>nOrig</i> the number of points in the data set in the dimension given by the
 second argument <i>dim</i> whose transform could have led to the present data, or equivalently the number of
 points in the two-sided full-bandwidth spectrum from which the present spectrum could have been derived.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#setTwoSided(boolean)">setTwoSided</a></strong>(boolean&nbsp;s)</code>
<div class="block">Sets the two-sidedness flag to the value of the argument.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#setUpperFrequencyBound(double)">setUpperFrequencyBound</a></strong>(double&nbsp;hf)</code>
<div class="block">Sets the (non-negative) value of the highest frequency in the frequency band held in the object to the given
 value.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#setUpperFrequencyBound(double, int)">setUpperFrequencyBound</a></strong>(double&nbsp;hf,
                      int&nbsp;dim)</code>
<div class="block">Sets or resets the (non-negative) value of the highest frequency in the frequency band held in the object for the
 given direction <i>dim</i> to the value of the given argument <i>hf</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/ComplexSpectrum.html#updateObsoletePointers()">updateObsoletePointers</a></strong>()</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_triana.types.VectorType">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;triana.types.<a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></h3>
<code><a href="../../triana/types/VectorType.html#getData()">getData</a>, <a href="../../triana/types/VectorType.html#getDataImag()">getDataImag</a>, <a href="../../triana/types/VectorType.html#getDataReal()">getDataReal</a>, <a href="../../triana/types/VectorType.html#getGraph()">getGraph</a>, <a href="../../triana/types/VectorType.html#getGraphImag()">getGraphImag</a>, <a href="../../triana/types/VectorType.html#getGraphReal()">getGraphReal</a>, <a href="../../triana/types/VectorType.html#getScale()">getScale</a>, <a href="../../triana/types/VectorType.html#getScaleImag()">getScaleImag</a>, <a href="../../triana/types/VectorType.html#getScaleReal()">getScaleReal</a>, <a href="../../triana/types/VectorType.html#getXArray()">getXArray</a>, <a href="../../triana/types/VectorType.html#getXImag()">getXImag</a>, <a href="../../triana/types/VectorType.html#getXReal()">getXReal</a>, <a href="../../triana/types/VectorType.html#getXTriplet()">getXTriplet</a>, <a href="../../triana/types/VectorType.html#initialiseData()">initialiseData</a>, <a href="../../triana/types/VectorType.html#initialiseDataComplex(int)">initialiseDataComplex</a>, <a href="../../triana/types/VectorType.html#initialiseDataReal(int)">initialiseDataReal</a>, <a href="../../triana/types/VectorType.html#isTriplet()">isTriplet</a>, <a href="../../triana/types/VectorType.html#isUniform()">isUniform</a>, <a href="../../triana/types/VectorType.html#length()">length</a>, <a href="../../triana/types/VectorType.html#setData(double[])">setData</a>, <a href="../../triana/types/VectorType.html#setData(double[], double[])">setData</a>, <a href="../../triana/types/VectorType.html#setDataImag(double[])">setDataImag</a>, <a href="../../triana/types/VectorType.html#setDataReal(double[])">setDataReal</a>, <a href="../../triana/types/VectorType.html#setX(double[])">setX</a>, <a href="../../triana/types/VectorType.html#setX(double[], double[])">setX</a>, <a href="../../triana/types/VectorType.html#setX(triana.types.util.Triplet)">setX</a>, <a href="../../triana/types/VectorType.html#setXImag(double[])">setXImag</a>, <a href="../../triana/types/VectorType.html#setXReal(double[])">setXReal</a>, <a href="../../triana/types/VectorType.html#size()">size</a>, <a href="../../triana/types/VectorType.html#testDataModel()">testDataModel</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_triana.types.GraphType">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;triana.types.<a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></h3>
<code><a href="../../triana/types/GraphType.html#add(java.lang.Object)">add</a>, <a href="../../triana/types/GraphType.html#addToTitle(java.lang.String)">addToTitle</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToBytes()">convertDependentDataArraysToBytes</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToDoubles()">convertDependentDataArraysToDoubles</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToFloats()">convertDependentDataArraysToFloats</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToInts()">convertDependentDataArraysToInts</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToLongs()">convertDependentDataArraysToLongs</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToShorts()">convertDependentDataArraysToShorts</a>, <a href="../../triana/types/GraphType.html#copyData(triana.types.TrianaType)">copyData</a>, <a href="../../triana/types/GraphType.html#copyLabels()">copyLabels</a>, <a href="../../triana/types/GraphType.html#divide(java.lang.Object)">divide</a>, <a href="../../triana/types/GraphType.html#equals(java.lang.Object)">equals</a>, <a href="../../triana/types/GraphType.html#getDataArrayClass(int)">getDataArrayClass</a>, <a href="../../triana/types/GraphType.html#getDataArrayImag(int)">getDataArrayImag</a>, <a href="../../triana/types/GraphType.html#getDataArrayImag(int, java.lang.Class)">getDataArrayImag</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsBytes(int)">getDataArrayImagAsBytes</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsDoubles(int)">getDataArrayImagAsDoubles</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsFloats(int)">getDataArrayImagAsFloats</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsInts(int)">getDataArrayImagAsInts</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsLongs(int)">getDataArrayImagAsLongs</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsShorts(int)">getDataArrayImagAsShorts</a>, <a href="../../triana/types/GraphType.html#getDataArrayReal(int)">getDataArrayReal</a>, <a href="../../triana/types/GraphType.html#getDataArrayReal(int, java.lang.Class)">getDataArrayReal</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsBytes(int)">getDataArrayRealAsBytes</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsDoubles(int)">getDataArrayRealAsDoubles</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsFloats(int)">getDataArrayRealAsFloats</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsInts(int)">getDataArrayRealAsInts</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsLongs(int)">getDataArrayRealAsLongs</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsShorts(int)">getDataArrayRealAsShorts</a>, <a href="../../triana/types/GraphType.html#getDataArrayTypeNames(int)">getDataArrayTypeNames</a>, <a href="../../triana/types/GraphType.html#getDependentLabels(int)">getDependentLabels</a>, <a href="../../triana/types/GraphType.html#getDependentVariableDimensions(int)">getDependentVariableDimensions</a>, <a href="../../triana/types/GraphType.html#getDependentVariables()">getDependentVariables</a>, <a href="../../triana/types/GraphType.html#getDimensionLengths()">getDimensionLengths</a>, <a href="../../triana/types/GraphType.html#getDimensionLengths(int)">getDimensionLengths</a>, <a href="../../triana/types/GraphType.html#getGraphArrayImagLog10(int)">getGraphArrayImagLog10</a>, <a href="../../triana/types/GraphType.html#getGraphArrayRealLog10(int)">getGraphArrayRealLog10</a>, <a href="../../triana/types/GraphType.html#getIndependentArrayImag(int)">getIndependentArrayImag</a>, <a href="../../triana/types/GraphType.html#getIndependentArrayReal(int)">getIndependentArrayReal</a>, <a href="../../triana/types/GraphType.html#getIndependentLabels(int)">getIndependentLabels</a>, <a href="../../triana/types/GraphType.html#getIndependentScaleImagLog10(int)">getIndependentScaleImagLog10</a>, <a href="../../triana/types/GraphType.html#getIndependentScaleRealLog10(int)">getIndependentScaleRealLog10</a>, <a href="../../triana/types/GraphType.html#getIndependentTriplet(int)">getIndependentTriplet</a>, <a href="../../triana/types/GraphType.html#getIndependentVariables()">getIndependentVariables</a>, <a href="../../triana/types/GraphType.html#getLabels()">getLabels</a>, <a href="../../triana/types/GraphType.html#getLabelsColumn()">getLabelsColumn</a>, <a href="../../triana/types/GraphType.html#getTitle()">getTitle</a>, <a href="../../triana/types/GraphType.html#isArithmeticArray(int)">isArithmeticArray</a>, <a href="../../triana/types/GraphType.html#isArithmeticData(int)">isArithmeticData</a>, <a href="../../triana/types/GraphType.html#isCompatible(java.lang.Object)">isCompatible</a>, <a href="../../triana/types/GraphType.html#isDependentComplex(int)">isDependentComplex</a>, <a href="../../triana/types/GraphType.html#isIndependentComplex(int)">isIndependentComplex</a>, <a href="../../triana/types/GraphType.html#isPrimitiveArray(int)">isPrimitiveArray</a>, <a href="../../triana/types/GraphType.html#isPrimitiveData(int)">isPrimitiveData</a>, <a href="../../triana/types/GraphType.html#isTriplet(int)">isTriplet</a>, <a href="../../triana/types/GraphType.html#isUniform(int)">isUniform</a>, <a href="../../triana/types/GraphType.html#maxDependentGraphingValuesImag()">maxDependentGraphingValuesImag</a>, <a href="../../triana/types/GraphType.html#maxDependentGraphingValuesReal()">maxDependentGraphingValuesReal</a>, <a href="../../triana/types/GraphType.html#maxDependentVariablesImag()">maxDependentVariablesImag</a>, <a href="../../triana/types/GraphType.html#maxDependentVariablesReal()">maxDependentVariablesReal</a>, <a href="../../triana/types/GraphType.html#maxIndependentScalesImag()">maxIndependentScalesImag</a>, <a href="../../triana/types/GraphType.html#maxIndependentScalesReal()">maxIndependentScalesReal</a>, <a href="../../triana/types/GraphType.html#maxIndependentVariablesImag()">maxIndependentVariablesImag</a>, <a href="../../triana/types/GraphType.html#maxIndependentVariablesReal()">maxIndependentVariablesReal</a>, <a href="../../triana/types/GraphType.html#minDependentGraphingValuesImag()">minDependentGraphingValuesImag</a>, <a href="../../triana/types/GraphType.html#minDependentGraphingValuesReal()">minDependentGraphingValuesReal</a>, <a href="../../triana/types/GraphType.html#minDependentVariablesImag()">minDependentVariablesImag</a>, <a href="../../triana/types/GraphType.html#minDependentVariablesReal()">minDependentVariablesReal</a>, <a href="../../triana/types/GraphType.html#minIndependentScalesImag()">minIndependentScalesImag</a>, <a href="../../triana/types/GraphType.html#minIndependentScalesReal()">minIndependentScalesReal</a>, <a href="../../triana/types/GraphType.html#minIndependentVariablesImag()">minIndependentVariablesImag</a>, <a href="../../triana/types/GraphType.html#minIndependentVariablesReal()">minIndependentVariablesReal</a>, <a href="../../triana/types/GraphType.html#multiply(java.lang.Object)">multiply</a>, <a href="../../triana/types/GraphType.html#resetDependent(int)">resetDependent</a>, <a href="../../triana/types/GraphType.html#resetIndependent(int)">resetIndependent</a>, <a href="../../triana/types/GraphType.html#restrictToSubdomain(int, double, double)">restrictToSubdomain</a>, <a href="../../triana/types/GraphType.html#restrictToSubdomain(int, int, int)">restrictToSubdomain</a>, <a href="../../triana/types/GraphType.html#setDataArrayImag(java.lang.Object, int)">setDataArrayImag</a>, <a href="../../triana/types/GraphType.html#setDataArrayReal(java.lang.Object, int)">setDataArrayReal</a>, <a href="../../triana/types/GraphType.html#setDependentLabels(int, java.lang.String)">setDependentLabels</a>, <a href="../../triana/types/GraphType.html#setDependentVariableDimensions(int[], int)">setDependentVariableDimensions</a>, <a href="../../triana/types/GraphType.html#setDimensionLengths(int[])">setDimensionLengths</a>, <a href="../../triana/types/GraphType.html#setDimensionLengths(int, int)">setDimensionLengths</a>, <a href="../../triana/types/GraphType.html#setDimensions(int, int)">setDimensions</a>, <a href="../../triana/types/GraphType.html#setIndependentArrayImag(double[], int)">setIndependentArrayImag</a>, <a href="../../triana/types/GraphType.html#setIndependentArrayReal(double[], int)">setIndependentArrayReal</a>, <a href="../../triana/types/GraphType.html#setIndependentLabels(int, java.lang.String)">setIndependentLabels</a>, <a href="../../triana/types/GraphType.html#setIndependentTriplet(int, double, double, int)">setIndependentTriplet</a>, <a href="../../triana/types/GraphType.html#setIndependentTriplet(triana.types.util.Triplet, int)">setIndependentTriplet</a>, <a href="../../triana/types/GraphType.html#setLabels(java.util.Hashtable)">setLabels</a>, <a href="../../triana/types/GraphType.html#setTitle(java.lang.String)">setTitle</a>, <a href="../../triana/types/GraphType.html#subtract(java.lang.Object)">subtract</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_triana.types.TrianaType">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;triana.types.<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a></h3>
<code><a href="../../triana/types/TrianaType.html#containerSize()">containerSize</a>, <a href="../../triana/types/TrianaType.html#dataExists(java.lang.Object)">dataExists</a>, <a href="../../triana/types/TrianaType.html#deleteFromContainer(java.lang.Object)">deleteFromContainer</a>, <a href="../../triana/types/TrianaType.html#getDataContainer()">getDataContainer</a>, <a href="../../triana/types/TrianaType.html#getFromContainer(java.lang.Object)">getFromContainer</a>, <a href="../../triana/types/TrianaType.html#getSequenceNumber()">getSequenceNumber</a>, <a href="../../triana/types/TrianaType.html#insertIntoContainer(java.lang.Object, java.lang.Object)">insertIntoContainer</a>, <a href="../../triana/types/TrianaType.html#inspectDataContainer()">inspectDataContainer</a>, <a href="../../triana/types/TrianaType.html#setDataContainer(java.util.Hashtable)">setDataContainer</a>, <a href="../../triana/types/TrianaType.html#setSequenceNumber(int)">setSequenceNumber</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="samplingFrequency">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>samplingFrequency</h4>
<pre>public&nbsp;double samplingFrequency</pre>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete. It must be kept to the
 right values by the <i>updateObsoletePointers</i> method and/or constructors and <i>set...</i> methods.) </p><p>
 The sampling frequency -- this will not be supported in later versions, since it is part of the Signal interface
 and not the Spectral interface</div>
</li>
</ul>
<a name="frequencyResolution">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>frequencyResolution</h4>
<pre>public&nbsp;double frequencyResolution</pre>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete. It must be kept to the
 right values by the <i>updateObsoletePointers</i> method and/or constructors and <i>set...</i> methods.) </p><p>
 The frequency resolution -- this is obsolete because it is public, and has been replaced by the private parameter
 <i>resolution</i>.</div>
</li>
</ul>
<a name="imag">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>imag</h4>
<pre>public&nbsp;double[] imag</pre>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete. It must be kept to the
 right values by the <i>updateObsoletePointers</i> method and/or constructors and <i>set...</i> methods.) </p><p>
 The imaginary part of the signal</div>
</li>
</ul>
<a name="real">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>real</h4>
<pre>public&nbsp;double[] real</pre>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete. It must be kept to the
 right values by the <i>updateObsoletePointers</i> method and/or constructors and <i>set...</i> methods.) </p><p>
 The real part of the signal</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="ComplexSpectrum()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ComplexSpectrum</h4>
<pre>public&nbsp;ComplexSpectrum()</pre>
<div class="block">Create and empty ComplexSpectrum with no parameters set.</div>
</li>
</ul>
<a name="ComplexSpectrum(double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ComplexSpectrum</h4>
<pre>public&nbsp;ComplexSpectrum(double&nbsp;sf,
               int&nbsp;points)</pre>
<div class="block">This is an obsolete Constructor that will be eliminated when possible. It uses <i>samplingFrequency</i>, a
 parameter that is obsolete. It is distinguished from the constructors that should be used by not having a boolean
 argument. This Constructor creates a new one-sided ComplexSpectrum with a certain sampling frequency and number
 of points. It also allocates memory for the data but does not initialise it.  Use <i>initialiseData</i> to set
 all elements to zero.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sf</code> - is the sampling frequency</dd><dd><code>points</code> - is the number of points</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../triana/types/VectorType.html#initialiseData()"><code>VectorType.initialiseData()</code></a></dd></dl>
</li>
</ul>
<a name="ComplexSpectrum(double, double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ComplexSpectrum</h4>
<pre>public&nbsp;ComplexSpectrum(double&nbsp;samplingFrequency,
               double[]&nbsp;real)</pre>
<div class="block">This is an obsolete Constructor that creates a new one-sided ComplexSpectrum with a certain sampling frequency
 and the actual allocated real data. The imaginary data is allocated and intialised to 0. It uses
 <i>samplingFrequency</i>, a parameter that is obsolete. It is distinguished from the constructors that should be
 used by not having a boolean argument.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>samplingFrequency</code> - is the sampling frequency</dd><dd><code>real</code> - the actual allocated data</dd></dl>
</li>
</ul>
<a name="ComplexSpectrum(double, double[], double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ComplexSpectrum</h4>
<pre>public&nbsp;ComplexSpectrum(double&nbsp;samplingFrequency,
               double[]&nbsp;real,
               double[]&nbsp;imag)</pre>
<div class="block">This is an obsolete Constructor that creates a new one-sided ComplexSpectrum with a certain sampling frequency
 and the actual allocated complex data. It uses <i>samplingFrequency</i>, a parameter that is obsolete. It is
 distinguished from the constructors that should be used by not having a boolean argument.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>samplingFrequency</code> - is the sampling frequency</dd><dd><code>real</code> - The real part of the given data</dd><dd><code>imag</code> - The imaginary part of the given data</dd></dl>
</li>
</ul>
<a name="ComplexSpectrum(boolean, boolean, int, int, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ComplexSpectrum</h4>
<pre>public&nbsp;ComplexSpectrum(boolean&nbsp;ts,
               boolean&nbsp;nrw,
               int&nbsp;len,
               int&nbsp;nOrig,
               double&nbsp;df,
               double&nbsp;hf)</pre>
<div class="block">Creates a new ComplexSpectrum with arguments giving the sidedness, whether it is narrow-band or broad-band, the
 data length, the number of points in the original broad-band spectrum, the frequency resolution, and the highest
 frequency in the current spectrum. It does not allocate data. Various checks are performed on the consistency of
 the input parameters with the Triana spectral storage model, and error messages are printed to
 <i>System.out</i>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ts</code> - <i>True</i> if the new ComplexSpectrum is to be two-sided</dd><dd><code>nrw</code> - <i>True</i> if the new ComplexSpectrum is to be narrow-band</dd><dd><code>len</code> - Number of points in the current data set</dd><dd><code>nOrig</code> - Number of points in the original two-sided full spectrum</dd><dd><code>df</code> - Frequency resolution</dd><dd><code>hf</code> - Highest frequency in the current data set</dd></dl>
</li>
</ul>
<a name="ComplexSpectrum(boolean, boolean, double[], double[], int, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ComplexSpectrum</h4>
<pre>public&nbsp;ComplexSpectrum(boolean&nbsp;ts,
               boolean&nbsp;nrw,
               double[]&nbsp;real,
               double[]&nbsp;imag,
               int&nbsp;nOrig,
               double&nbsp;df,
               double&nbsp;hf)</pre>
<div class="block">Creates a new ComplexSpectrum with arguments giving the sidedness, whether it is narrow-band or broad-band, the
 data arrays, the number of points in the original broad-band spectrum, the frequency resolution, and the highest
 frequency in the current spectrum.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ts</code> - <i>True</i> if the new ComplexSpectrum is to be two-sided</dd><dd><code>nrw</code> - <i>True</i> if the new ComplexSpectrum is to be narrow-band</dd><dd><code>real</code> - Real part of the data</dd><dd><code>imag</code> - Imaginary part of the data</dd><dd><code>nOrig</code> - Number of points in the original two-sided full spectrum</dd><dd><code>df</code> - Frequency resolution</dd><dd><code>hf</code> - Highest frequency in the current data set</dd></dl>
</li>
</ul>
<a name="ComplexSpectrum(boolean, int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ComplexSpectrum</h4>
<pre>public&nbsp;ComplexSpectrum(boolean&nbsp;ts,
               int&nbsp;nOrig,
               double&nbsp;df)</pre>
<div class="block">Creates a new ComplexSpectrum with a given sidedness, number of points that there would be in the two-sided
 spectrum, and frequency resolution. It does not allocate memory for the data. It assumes that the data are
 full-bandwidth.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ts</code> - <i>True</i> if the new ComplexSpectrum is to be two-sided</dd><dd><code>nOrig</code> - Number of points in the equivalent two-sided spectrum</dd><dd><code>df</code> - Frequency resolution</dd></dl>
</li>
</ul>
<a name="ComplexSpectrum(boolean, double[], double[], int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ComplexSpectrum</h4>
<pre>public&nbsp;ComplexSpectrum(boolean&nbsp;ts,
               double[]&nbsp;real,
               double[]&nbsp;imag,
               int&nbsp;nOrig,
               double&nbsp;df)</pre>
<div class="block">Creates a new ComplexSpectrum with given sidedness, data arrays, number of points in the two-sided spectrum, and
 frequency resolution. It assumes that the data are full-bandwidth. The lengths of the input data arrays will be
 shorter than the size of the two-sided spectrum if the input is one-sided.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ts</code> - <i>True</i> if the new ComplexSpectrum is to be two-sided</dd><dd><code>real</code> - The real part of the input spectrum</dd><dd><code>imag</code> - The imaginary part of the input spectrum</dd><dd><code>nOrig</code> - Number of points in the equivalent two-sided spectrum</dd><dd><code>df</code> - Frequency resolution</dd></dl>
</li>
</ul>
<a name="ComplexSpectrum(triana.types.Spectrum, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ComplexSpectrum</h4>
<pre>public&nbsp;ComplexSpectrum(<a href="../../triana/types/Spectrum.html" title="class in triana.types">Spectrum</a>&nbsp;s,
               boolean&nbsp;copy)</pre>
<div class="block">Creates a ComplexSpectrum from a (real) Spectrum by setting the imaginary part of the data to zero. The second
 argument is used to choose whether the real data are copied or passed by reference.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>s</code> - The input data set</dd><dd><code>copy</code> - True if the new data are to be copied from the old, false if passed by reference</dd></dl>
</li>
</ul>
<a name="ComplexSpectrum(triana.types.Spectrum)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>ComplexSpectrum</h4>
<pre>public&nbsp;ComplexSpectrum(<a href="../../triana/types/Spectrum.html" title="class in triana.types">Spectrum</a>&nbsp;s)</pre>
<div class="block">Creates a ComplexSpectrum from a (real) Spectrum by setting the imaginary part of the data to zero. The real data
 are passed by reference.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>s</code> - The input data set</dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="setDefaultAxisLabelling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDefaultAxisLabelling</h4>
<pre>public&nbsp;void&nbsp;setDefaultAxisLabelling()</pre>
<div class="block">Added by I. Taylor, August 2001 : This function sets the default labeling scheme used for the axis by this data
 type. All constructors call this function to set default values for the axis.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#setDefaultAxisLabelling()">setDefaultAxisLabelling</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
</dl>
</li>
</ul>
<a name="getFrequencyResolution(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFrequencyResolution</h4>
<pre>public&nbsp;double&nbsp;getFrequencyResolution(int&nbsp;dim)</pre>
<div class="block">Returns the frequency resolution of the data for the given dimension (independent variable). Since there is only
 one dimension in this object, this argument is ignored. This form of the method is required by the Spectral
 interface.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getFrequencyResolution(int)">getFrequencyResolution</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd>
<dt><span class="strong">Returns:</span></dt><dd>The frequency resolution</dd></dl>
</li>
</ul>
<a name="getFrequencyResolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFrequencyResolution</h4>
<pre>public&nbsp;double&nbsp;getFrequencyResolution()</pre>
<div class="block">Returns the frequency resolution of the data.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>double The frequency resolution</dd></dl>
</li>
</ul>
<a name="setFrequencyResolution(double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFrequencyResolution</h4>
<pre>public&nbsp;void&nbsp;setFrequencyResolution(double&nbsp;df,
                          int&nbsp;dim)</pre>
<div class="block">Sets the frequency resolution of the data for the given dimension to the given value. Since the data are one
 dimensional, the dimension argument is in fact ignored. This form of the method is required by the Spectral
 interface.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#setFrequencyResolution(double, int)">setFrequencyResolution</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd><dd><code>df</code> - The frequency resolution</dd></dl>
</li>
</ul>
<a name="setFrequencyResolution(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFrequencyResolution</h4>
<pre>public&nbsp;void&nbsp;setFrequencyResolution(double&nbsp;df)</pre>
<div class="block">Sets the frequency resolution of the data to the given value.</div>
</li>
</ul>
<a name="isTwoSided()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isTwoSided</h4>
<pre>public&nbsp;boolean&nbsp;isTwoSided()</pre>
<div class="block">Returns <i>true</i> if the data are stored as a two-sided transform, i.e. containing both the positive and
 negative frequency data. If <i>false</i>, the data are one-sided, containing only positive frequencies.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#isTwoSided()">isTwoSided</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>boolean True if data are two-sided in frequency space</dd></dl>
</li>
</ul>
<a name="setTwoSided(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTwoSided</h4>
<pre>public&nbsp;void&nbsp;setTwoSided(boolean&nbsp;s)</pre>
<div class="block">Sets the two-sidedness flag to the value of the argument.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#setTwoSided(boolean)">setTwoSided</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>s</code> - True if the data will be two-sided</dd></dl>
</li>
</ul>
<a name="getOriginalN(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOriginalN</h4>
<pre>public&nbsp;int&nbsp;getOriginalN(int&nbsp;dim)</pre>
<div class="block">Returns the number of points in the data set in the given dimension whose transform could have led to the present
 data, or equivalently the number of points in the two-sided full-bandwidth spectrum from which the present
 spectrum could have been derived. Because the set is one-dimensional, the dimension argument is ignored. This
 form of the method is required by the Spectral interface.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getOriginalN(int)">getOriginalN</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd>
<dt><span class="strong">Returns:</span></dt><dd>The number of points in the original data set</dd></dl>
</li>
</ul>
<a name="getOriginalN()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOriginalN</h4>
<pre>public&nbsp;int&nbsp;getOriginalN()</pre>
<div class="block">Returns the number of points in the data set whose transform could have led to the present data, or equivalently
 the number of points in the two-sided full-bandwidth spectrum from which the present spectrum could have been
 derived.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>int The number of points in the original data set</dd></dl>
</li>
</ul>
<a name="setOriginalN(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOriginalN</h4>
<pre>public&nbsp;void&nbsp;setOriginalN(int&nbsp;nOrig,
                int&nbsp;dim)</pre>
<div class="block">Sets to the given first argument <i>nOrig</i> the number of points in the data set in the dimension given by the
 second argument <i>dim</i> whose transform could have led to the present data, or equivalently the number of
 points in the two-sided full-bandwidth spectrum from which the present spectrum could have been derived. Because
 the data are one-dimensional, the value of <i>dim</i> is ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#setOriginalN(int, int)">setOriginalN</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd><dd><code>nOrig</code> - The new number of points in the original data set</dd></dl>
</li>
</ul>
<a name="setOriginalN(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOriginalN</h4>
<pre>public&nbsp;void&nbsp;setOriginalN(int&nbsp;nOrig)</pre>
<div class="block">Sets to the given argument the number of points in the data set whose transform could have led to the present
 data, or equivalently the number of points in the two-sided full-bandwidth spectrum from which the present
 spectrum could have been derived.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>nOrig</code> - The new number of points in the original data set</dd></dl>
</li>
</ul>
<a name="isNarrow(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isNarrow</h4>
<pre>public&nbsp;boolean&nbsp;isNarrow(int&nbsp;dim)</pre>
<div class="block">Returns true if the data for the given dimension represent a narrow bandwidth derived from a full-band spectrum.
 This form of the method is required by the Spectral interface.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#isNarrow(int)">isNarrow</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd>
<dt><span class="strong">Returns:</span></dt><dd>True if data are narrow-band</dd></dl>
</li>
</ul>
<a name="isNarrow()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isNarrow</h4>
<pre>public&nbsp;boolean&nbsp;isNarrow()</pre>
<div class="block">Returns true if the data represent a narrow bandwidth derived from a full-band spectrum.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>True if data are narrow-band</dd></dl>
</li>
</ul>
<a name="setNarrow(boolean, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNarrow</h4>
<pre>public&nbsp;void&nbsp;setNarrow(boolean&nbsp;n,
             int&nbsp;dim)</pre>
<div class="block">Sets the narrow-bandedness flag associated with the given dimension to the value of the argument. Since the data
 are one-dimensional, the value of <i>dim</i> is ignored. This form of the method is required by the Spectral
 interface.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#setNarrow(boolean, int)">setNarrow</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>n</code> - True if the data held are narrow-band</dd><dd><code>dim</code> - The index of the independent variable being set</dd></dl>
</li>
</ul>
<a name="setNarrow(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNarrow</h4>
<pre>public&nbsp;void&nbsp;setNarrow(boolean&nbsp;n)</pre>
<div class="block">Sets the narrow-bandedness flag to the value of the argument.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>n</code> - True if the data held are narrow-band</dd></dl>
</li>
</ul>
<a name="getLowerFrequencyBound(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLowerFrequencyBound</h4>
<pre>public&nbsp;double&nbsp;getLowerFrequencyBound(int&nbsp;dim)</pre>
<div class="block">Returns the (non-negative) value of the lowest frequency in the frequency band held in the object, for the given
 dimension <i>dim</i>. The data are one-dimensional so <i>dim</i> is ignored. This form of the method is required
 by the Spectral interface.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getLowerFrequencyBound(int)">getLowerFrequencyBound</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd>
<dt><span class="strong">Returns:</span></dt><dd>The lowest frequency represented in the given direction</dd></dl>
</li>
</ul>
<a name="getLowerFrequencyBound()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLowerFrequencyBound</h4>
<pre>public&nbsp;double&nbsp;getLowerFrequencyBound()</pre>
<div class="block">Returns the (non-negative) value of the lowest frequency in the frequency band held in the object.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>double The lowest frequency represented in the given direction</dd></dl>
</li>
</ul>
<a name="getUpperFrequencyBound(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUpperFrequencyBound</h4>
<pre>public&nbsp;double&nbsp;getUpperFrequencyBound(int&nbsp;dim)</pre>
<div class="block">Returns the (non-negative) value of the highest frequency in the frequency band held in the object, for the given
 dimension <i>dim</i>. The data are one-dimensional so <i>dim</i> is ignored. This form of the method is required
 by the Spectral interface.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getUpperFrequencyBound(int)">getUpperFrequencyBound</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd>
<dt><span class="strong">Returns:</span></dt><dd>The highest frequency represented in the given direction</dd></dl>
</li>
</ul>
<a name="getUpperFrequencyBound()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUpperFrequencyBound</h4>
<pre>public&nbsp;double&nbsp;getUpperFrequencyBound()</pre>
<div class="block">Returns the (non-negative) value of the highest frequency in the frequency band held in the object.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>double The highest frequency represented in the given direction</dd></dl>
</li>
</ul>
<a name="setUpperFrequencyBound(double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUpperFrequencyBound</h4>
<pre>public&nbsp;void&nbsp;setUpperFrequencyBound(double&nbsp;hf,
                          int&nbsp;dim)</pre>
<div class="block">Sets or resets the (non-negative) value of the highest frequency in the frequency band held in the object for the
 given direction <i>dim</i> to the value of the given argument <i>hf</i>.  Should be used after altering
 parameters or data in the object if they have changed the upper frequency bound. Because the data are
 one-dimensional, the value of <i>dim</i> is ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#setUpperFrequencyBound(double, int)">setUpperFrequencyBound</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd><dd><code>hf</code> - The new highest frequency represented in the given direction</dd></dl>
</li>
</ul>
<a name="setUpperFrequencyBound(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUpperFrequencyBound</h4>
<pre>public&nbsp;void&nbsp;setUpperFrequencyBound(double&nbsp;hf)</pre>
<div class="block">Sets the (non-negative) value of the highest frequency in the frequency band held in the object to the given
 value. Should be used after altering parameters or data in the object if they have changed the upper frequency
 bound. This should also set the <i>isNarrow</i> flag if the given value is not the highest value of the
 original-length spectrum.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>hf</code> - The new highest frequency</dd></dl>
</li>
</ul>
<a name="getFrequencyArray(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFrequencyArray</h4>
<pre>public&nbsp;double[]&nbsp;getFrequencyArray(int&nbsp;dim)</pre>
<div class="block">Returns the frequency values of the independent data points for the given dimension, in the order of lowest
 frequency to highest, regardless of how the data are stored internally.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getFrequencyArray(int)">getFrequencyArray</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The dimension of the independent variable</dd>
<dt><span class="strong">Returns:</span></dt><dd>double[] Array of ordered frequency values</dd></dl>
</li>
</ul>
<a name="getOrderedSpectrumReal()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOrderedSpectrumReal</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getOrderedSpectrumReal()</pre>
<div class="block">Returns the real parts of the values of the spectrum (data points) in a multidimensional array, ordered so that
 in each dimension the values correspond to frequencies running from the lowest to the highest, regardless of the
 internal data model. These points then correspond to the values returned by <i>getFrequencyArray</i> for each
 dimension.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getOrderedSpectrumReal()">getOrderedSpectrumReal</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>Object Multidimensional arrray of ordered spectral values</dd></dl>
</li>
</ul>
<a name="getOrderedSpectrumImag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOrderedSpectrumImag</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getOrderedSpectrumImag()</pre>
<div class="block">Returns the imaginary parts of the values of the spectrum (data points) in a multidimensional array, ordered so
 that in each dimension the values correspond to frequencies running from the lowest to the highest, regardless of
 the internal data model. These points then correspond to the values returned by <i>getFrequencyArray</i> for each
 dimension.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getOrderedSpectrumImag()">getOrderedSpectrumImag</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>Object Multidimensional arrray of ordered spectral values</dd></dl>
</li>
</ul>
<a name="getNyquist()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNyquist</h4>
<pre>public&nbsp;double&nbsp;getNyquist()</pre>
<div class="block">Returns the Nyquist frequency, defined to be the highest frequency that this data set could contain if it were
 not narrow-banded. For full-bandwidth sets, this is the same value as is returned by
 <i>getUpperFrequencyBound()</i>, but for narrow-band data sets it may be higher. </p><p> The general formula is
 that if the original number of data points (given by <i> nFull = getOriginalN()</i>) is even, then the Nyquist
 frequency is <i>nFull * resolution / 2</i>. If the original number of data points is odd, then the Nyquist
 frequency is <i>(nFull -1 ) * resolution / 2</i>.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>double The Nyquist frequency</dd></dl>
</li>
</ul>
<a name="getSamplingRate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSamplingRate</h4>
<pre>public&nbsp;double&nbsp;getSamplingRate()</pre>
<div class="block">Returns the sampling frequency that a time-series would have had if it had led to the present spectral data set.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>double The sampling frequency</dd></dl>
</li>
</ul>
<a name="samplingFrequency()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>samplingFrequency</h4>
<pre>public&nbsp;double&nbsp;samplingFrequency()</pre>
<div class="block">Obsolete method for obtaining sampling frequency. Will be withdrawn.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the sampling frequency</dd></dl>
</li>
</ul>
<a name="points()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>points</h4>
<pre>public&nbsp;int&nbsp;points()</pre>
<div class="block">Obsolete method for obtaining the number of data points. Will be withdrawn.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the number of points in this ComplexSpectrum</dd></dl>
</li>
</ul>
<a name="frequencyResolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>frequencyResolution</h4>
<pre>public&nbsp;double&nbsp;frequencyResolution()</pre>
<div class="block">Obsolete method for obtaining frequency resolution. Will be withdrawn.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the frequency resolution</dd></dl>
</li>
</ul>
<a name="getIndependentScaleReal(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIndependentScaleReal</h4>
<pre>public&nbsp;double[]&nbsp;getIndependentScaleReal(int&nbsp;dim)</pre>
<div class="block">Returns the independent data scaled the way they should be graphed.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#getIndependentScaleReal(int)">getIndependentScaleReal</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The independent dimension under consideration</dd>
<dt><span class="strong">Returns:</span></dt><dd>The scaled independent data values</dd></dl>
</li>
</ul>
<a name="getIndependentScaleImag(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIndependentScaleImag</h4>
<pre>public&nbsp;double[]&nbsp;getIndependentScaleImag(int&nbsp;dim)</pre>
<div class="block">Returns null because the data is real.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#getIndependentScaleImag(int)">getIndependentScaleImag</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The independent dimension under consideration</dd>
<dt><span class="strong">Returns:</span></dt><dd>The scaled independent data values</dd></dl>
</li>
</ul>
<a name="getGraphArrayReal(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGraphArrayReal</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getGraphArrayReal(int&nbsp;dv)</pre>
<div class="block">Returns the real part of the dependent variable ordered so that the frequency values all run monotonically
 upwards.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#getGraphArrayReal(int)">getGraphArrayReal</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dv</code> - The dependent variable dimension</dd>
<dt><span class="strong">Returns:</span></dt><dd>Object An array containing the rearranged data values</dd></dl>
</li>
</ul>
<a name="getGraphArrayImag(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGraphArrayImag</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getGraphArrayImag(int&nbsp;dv)</pre>
<div class="block">Returns the imaginary part of the dependent variable ordered so that the frequency values all run monotonically
 upwards.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#getGraphArrayImag(int)">getGraphArrayImag</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dv</code> - The dependent variable dimension</dd>
<dt><span class="strong">Returns:</span></dt><dd>Object An array containing the rearranged data values</dd></dl>
</li>
</ul>
<a name="extendWithZeros(int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extendWithZeros</h4>
<pre>public&nbsp;void&nbsp;extendWithZeros(int&nbsp;newLength,
                   boolean&nbsp;front)</pre>
<div class="block">Extends the data set to a longer set by padding with zeros, keeping the frequency resolution unchanged. If the
 new length is shorter than the old (as given by method <i>getOriginalN</i>, then nothing is done. This method
 does <i>not</i> use the method of the same name in VectorType. Instead it takes advantage of the narrow-band
 feature of the Triana spectral data model to add zeros "virtually", without increasing the storage required. The
 way this is done depends on the value of the given parameter <i>front</i>. </p><p> If <i>front</i> is
 <i>true</i>, then nothing is done and a warning message is printed to the debug stream, because it is not
 possible in the Triana spectral model to extend a spectrum "below" zero-frequency. Negative frequencies are
 already included in the spectrum either explictly or implicitly, so there is no room for more points at the
 "front" of the data set. Even if the data set is narrow-band and does not include zero frequency, the data down
 to zero frequency are already set to zero implicitly, so that there is no way to add more of them. </p><p> If the
 boolean argument <i>front</i> is <i>false</i>, then the method extends the spectrum to higher frequencies, but
 the extra zeros are added "virtually", <i>i.e.</i> by extending the length <i>nFull</i> of the original data set
 and not adding the zeros explicitly. If the original data set was broad-band, it is marked as narrow-band after
 extension. </p><p> The details of how this works are best understood by thinking of the original (un-extended)
 data set as having been obtained from the final (extended one) by low-pass filtering. It is a consequence of the
 Triana spectral data model that applying a low-pass filter to a full-bandwidth data set of any length
 <i>nFull</i> results in a data set whose new value of <i>nFull</i> is odd. If the data set before extension has
 an odd number of elements, then the extension requires only the actions described above. </p><p> On the other
 hand, if the data set before extension has an even value of <i>nFull</i>, then it must be converted to one with
 an odd number before it can be extended. This is done in this method by identifying all the elements of the old
 set with those of the new one with the same frequency except for the highest frequency. In the new (odd-length)
 set there are two elements for the highest frequency, one at positive frequency and one at negative. In the old
 (even-length) set there is only one, at the negative frequency. The elements of the new one are determined as
 follows: the negative-frequency element is set equal to the old negative-frequency element divided by sqrt(2),
 and the positive-frequency element is set equal to the complex-conjugate of this. This choice is rather
 arbitrary, but it ensures that, if this data set represents a Fourier transform, then the <i>total power</i> is
 unchanged. Of course, if the original data is narrow-band and has already lost its highest frequencies, then the
 new element is just set to zero, and this is done "virtually", by adjusting various parameters. If the data set
 is one-sided, then only the positive-frequency element is added. When an element is added, then the independent
 variable Triplet is extended by one as well.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/VectorType.html#extendWithZeros(int, boolean)">extendWithZeros</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>newLength</code> - The new length of the data set</dd><dd><code>front</code> - True if padding is at the front, false for padding at the back</dd></dl>
</li>
</ul>
<a name="interpolateZeros(int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interpolateZeros</h4>
<pre>public&nbsp;void&nbsp;interpolateZeros(int&nbsp;factor,
                    boolean&nbsp;before)</pre>
<div class="block">Inserts zeros in between existing elements of the data set. The integer argument <i>factor</i> gives the number
 of zeros per existing data point that must be inserted. The boolean argument <i>before</i> regulates whether the
 zeros should be inserted before each element (if <i>true</i>) or after (<i>false</i>). The new values of the
 independent variable are interpolated between those of the old ones. </p><p> If the argument <i>factor</i> is
 zero or negative, nothing is done. </p><p> In ComplexSpectrum, the interpolation is done in such a way that the
 frequency resolution is increased and the pre-existing data points remain at the same value of the frequency.
 This means that it is illegal to add zeroes before the first element, which corresponds to zero frequency. So if
 <i>before</i> is <i>true</i> then the method returns without doing anything, and prints a warning. </p><p> If the
 value of <i>before</i> is <i>false</i>, then the interpolation is done in such a way that the frequency
 resolution is divided by (<i>factor</i> + 1) and the original number of points is changed by (<i>factor</i> + 1).
 This ensures that the original data points remain at the same values of the frequency. The requisite number of
 zeros is added after each data point. If the spectrum is two-sided, then the way interpolation as done in
 <i>VectorType</i> is correct here too, and only the parameters are changed, as just described. If the spectrum is
 one-sided, then ordinary interpolation adds too many at the end, and this method removes the extra ones. </p><p>
 Derived types should override this if necessary to provide for the correct handling of parameters and other
 special features.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/VectorType.html#interpolateZeros(int, boolean)">interpolateZeros</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>factor</code> - The number of zeros per data point to be inserted</dd><dd><code>before</code> - <i>True</i> if the zeros go before each point, <i>false</i> if after</dd></dl>
</li>
</ul>
<a name="copyMe()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyMe</h4>
<pre>public&nbsp;<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;copyMe()</pre>
<div class="block">This is one of the most important methods of Triana data. types. It returns a copy of the type invoking it. This
 <b>must</b> be overridden for every derived data type derived. If not, the data cannot be copied to be given to
 other units. Copying must be done by value, not by reference. </p><p> To override, the programmer should not
 invoke the <i>super.copyMe</i> method. Instead, create an object of the current type and call methods
 <i>copyData</i> and <i>copyParameters</i>. If these have been written correctly, then they will do the copying.
 The code should createTool, for type YourType: <PRE> YourType y = null; try { y =
 (YourType)getClass().newInstance(); y.copyData( this ); y.copyParameters( this ); y.setLegend( this.getLegend()
 ); } catch (IllegalAccessException ee) { System.out.println("Illegal Access: " + ee.getMessage()); } catch
 (InstantiationException ee) { System.out.println("Couldn't be instantiated: " + ee.getMessage()); } return y;
 </PRE> </p><p> The copied object's data should be identical to the original. The method here modifies only one
 item: a String indicating that the object was created as a copy is added to the <i>description</i> StringVector.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/VectorType.html#copyMe()">copyMe</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>TrianaType Copy by value of the current Object except for an updated <i>description</i></dd></dl>
</li>
</ul>
<a name="copyParameters(triana.types.TrianaType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyParameters</h4>
<pre>protected&nbsp;void&nbsp;copyParameters(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;source)</pre>
<div class="block">Copies modifiable parameters from the argument object to the current object. The copying is by value, not by
 reference. Parameters are defined as data not held in <i>dataContainer</i>. They are modifiable if they have
 <i>set...</i> methods. Parameters that cannot be modified, but which are set by constructors, should be placed
 correctly into the copied object when it is constructed. </p><p> In ComplexSpectrum, the new parameters are
 <i>resolution</i>, <i>highestFrequency</i>, <i>twoSided</i>, <i>narrow</i>, <i>nFull</i>. The obsolete parameters
 <i>samplingFrequency</i> and <i>frequencyResolution</i> are generated automatically when the other parameters are
 copied and set. </p><p> This must be overridden by any subclass that defines new parameters. The overriding
 method should invoke its <i>super</i> method. It should use the <i>set...</i> and <i>get...</i> methods for the
 parameters in question. This method is protected so that it cannot be called except by objects that inherit from
 this one. It is called by <i>copyMe()</i>.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#copyParameters(triana.types.TrianaType)">copyParameters</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>source</code> - Data object that contains the data to be copied.</dd></dl>
</li>
</ul>
<a name="outputToStream(java.io.PrintWriter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outputToStream</h4>
<pre>public&nbsp;void&nbsp;outputToStream(java.io.PrintWriter&nbsp;dos)
                    throws java.io.IOException</pre>
<div class="block">Used when Triana types want to be able to send ASCII data to other programs using strings.  This is used to
 implement socket and to run other executables, written in C or other languages. With ASCII you don't have to
 worry about ENDIAN'ness as the conversions are all done via text. This is obviously slower than binary
 communication since you have to format the input and output within the other program. </p><p> This method must be
 overridden in every subclass that defines new data or parameters. The overriding method should first call<<PRE>
 super.outputToStream(dos) </PRE>to get output from superior classes, and then new parameters defined for the
 current subclass must be output. Moreover, subclasses that first dimension their data arrays must explicitly
 transfer these data arrays.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/AsciiComm.html#outputToStream(java.io.PrintWriter)">outputToStream</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/AsciiComm.html" title="interface in triana.types">AsciiComm</a></code></dd>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#outputToStream(java.io.PrintWriter)">outputToStream</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dos</code> - The data output stream</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="inputFromStream(java.io.BufferedReader)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inputFromStream</h4>
<pre>public&nbsp;void&nbsp;inputFromStream(java.io.BufferedReader&nbsp;dis)
                     throws java.io.IOException</pre>
<div class="block">Used when Triana types want to be able to receive ASCII data from the output of other programs.  This is used to
 implement socket and to run other executables, written in C or other languages. With ASCII you don't have to
 worry about ENDIAN'ness as the conversions are all done via text. This is obviously slower than binary
 communication since you have to format the input and output within the other program. </p><p> This method must be
 overridden in every subclass that defines new data or parameters. The overriding method should first call<PRE>
 super.inputFromStream(dis) </PRE>to get input from superior classes, and then new parameters defined for the
 current subclass must be input. Moreover, subclasses that first dimension their data arrays must explicitly
 transfer these data arrays.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/AsciiComm.html#inputFromStream(java.io.BufferedReader)">inputFromStream</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/AsciiComm.html" title="interface in triana.types">AsciiComm</a></code></dd>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#inputFromStream(java.io.BufferedReader)">inputFromStream</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dis</code> - The data input stream</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="isCompatible(triana.types.TrianaType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCompatible</h4>
<pre>public&nbsp;boolean&nbsp;isCompatible(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;obj)</pre>
<div class="block">Tests the argument object to determine if it makes sense to perform arithmetic operations between it and the
 current object. </p><p> In ComplexSpectrum, the method first tests that the input object is compatible with
 superior classes, and then (if it is a ComplexSpectrum( it tests if the input has the same frequency resolution,
 upper frequency bound, two-sidedness, and narrow-bandedness. </p><p> Classes derived from this should over-ride
 this method with further tests as appropriate. The over-riding method should normally have the first lines <PRE>
 boolean test = super.isCompatible( obj ); </PRE>followed by other tests. If other types not subclassed from
 GraphType or Const should be allowed to be compatible then other tests must be implemented.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/VectorType.html#isCompatible(triana.types.TrianaType)">isCompatible</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>obj</code> - The data object to be compared with the current one</dd>
<dt><span class="strong">Returns:</span></dt><dd><I>True</I> if the object can be combined with the current one</dd></dl>
</li>
</ul>
<a name="equals(triana.types.TrianaType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre>public&nbsp;boolean&nbsp;equals(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;obj)</pre>
<div class="block">Determines whether the argument TrianaType is equal to the current ComplexSpectrum. They are equal if the
 argument is a ComplexSpectrum with the same size, parameters, and data. </p><p> This method must be over-ridden
 in derived types. In a derived type called xxx the method should begin<PRE> if ( !( obj instanceof xxx ) ) return
 false; if ( !isCompatible( obj ) ) return false; </PRE>followed by tests that are specific to type xxx (testing
 its own parameters) and then as a last line<PRE> return super.equals( obj ); </PRE>This line invokes the other
 equals methods up the chain to GraphType. Each superior object tests its own parameters.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>obj</code> - The object being tested</dd>
<dt><span class="strong">Returns:</span></dt><dd>true if they are equal or false otherwise</dd></dl>
</li>
</ul>
<a name="updateObsoletePointers()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateObsoletePointers</h4>
<pre>protected&nbsp;void&nbsp;updateObsoletePointers()</pre>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/VectorType.html#updateObsoletePointers()">updateObsoletePointers</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></code></dd>
</dl>
</li>
</ul>
<a name="reduceNyquist(triana.types.ComplexSpectrum, boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>reduceNyquist</h4>
<pre>public static&nbsp;<a href="../../triana/types/ComplexSpectrum.html" title="class in triana.types">ComplexSpectrum</a>&nbsp;reduceNyquist(<a href="../../triana/types/ComplexSpectrum.html" title="class in triana.types">ComplexSpectrum</a>&nbsp;inputNarrow,
                            boolean&nbsp;allocMem)</pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../triana/types/ComplexSampleSet.html" title="class in triana.types"><span class="strong">Prev Class</span></a></li>
<li><a href="../../triana/types/Const.html" title="class in triana.types"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?triana/types/ComplexSpectrum.html" target="_top">Frames</a></li>
<li><a href="ComplexSpectrum.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
