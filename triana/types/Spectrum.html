<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_04) on Wed Sep 05 14:31:39 BST 2012 -->
<title>Spectrum</title>
<meta name="date" content="2012-09-05">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Spectrum";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../triana/types/Spectral.html" title="interface in triana.types"><span class="strong">Prev Class</span></a></li>
<li><a href="../../triana/types/Spectrum2D.html" title="class in triana.types"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?triana/types/Spectrum.html" target="_top">Frames</a></li>
<li><a href="Spectrum.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">triana.types</div>
<h2 title="Class Spectrum" class="title">Class Spectrum</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="../../triana/types/TrianaType.html" title="class in triana.types">triana.types.TrianaType</a></li>
<li>
<ul class="inheritance">
<li><a href="../../triana/types/GraphType.html" title="class in triana.types">triana.types.GraphType</a></li>
<li>
<ul class="inheritance">
<li><a href="../../triana/types/VectorType.html" title="class in triana.types">triana.types.VectorType</a></li>
<li>
<ul class="inheritance">
<li>triana.types.Spectrum</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.io.Serializable, <a href="../../triana/types/Arithmetic.html" title="interface in triana.types">Arithmetic</a>, <a href="../../triana/types/AsciiComm.html" title="interface in triana.types">AsciiComm</a>, <a href="../../triana/types/SequenceInterface.html" title="interface in triana.types">SequenceInterface</a>, <a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="strong">Spectrum</span>
extends <a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a>
implements <a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a>, <a href="../../triana/types/AsciiComm.html" title="interface in triana.types">AsciiComm</a></pre>
<div class="block">Spectrum is a subclass of VectorType that stores one or two one-dimensional arrays of double-precision real numbers
 representing either a real Fourier spectrum (normally a power spectrum or an amplitude spectrum) or a complex Fourier
 spectrum (normally the Fourier transform of a data set), a Triplet giving the integer values of the index of this
 array, and introduces five new parameters: a double <i>resolution</i> giving the frequency resolution; a double
 <i>highestFrequency</i> giving the value of the largest frequency represented in the data set; an int <i>nFull</i>
 giving the number of points in the original data set from which the data here were derived (used if the data have
 been reduced to one-sided or narrow-band spectra); and two boolean flags, (i) a flag <i>twoSided</i> that says
 whether the Spectrum is one-sided or two-sided, and (ii) a flag <i>narrow</i> that says whether the data are a narrow
 bandwidth derived from a larger full-bandwidth spectrum. Where ComplexSpectrum is the basic Triana class for holding
 one-dimensional Fourier tranforms, Spectrum is the basic class for power spectra. It implements the Spectral
 interface. In particular it implements the same Triana data storage model for storing spectral data. </p><p> The full
 Triana model is general enough to contain a multi-dimensional Fourier transform derived from a complex data set
 containing an arbitrary number of points. It is complete enough to ensure that inverse Fourier transforms can be done
 correctly automatically, even if the data set is a narrow-band spectrum extracted from a full spectrum that obeys the
 Triana model. The full Triana model is described fully in the ComplexSpectrum documentation. Spectrum implements
 those parts that do not require the complex phase of the full spectrum. In particular, it can contain spectra that
 are full-bandwidth or narrow-band. </p><p> First we deal with two-sided complete spectra, then one-sided. At the end
 we describe the way narrow bands are handled. The various descriptions assume a one-dimensional data set (one
 independent variable), but many could apply to each dimension of multi-dimensional sets. However, Spectrum can only
 handle one-dimensional data. </p><p> All spectral representations assume that the frequency values are uniformly
 spaced and are represented by an integer index <i>k</i>. The value of <i>resolution</i> is the (positive) difference
 between the frequencies associated with consecutive values of <i>k</i>. The index <i>k</i> is non-negative. </p><p> A
 two-sided Spectrum contains spectral values at both negative and positive frequencies. Values at non-negative
 frequencies are stored in the first part of the data vector in order of increasing frequency, and values at negative
 frequencies are stored in the second part, again in order of increasing frequency. The details depend on whether the
 total length of the spectral data set, <i>N</i>, is even or odd. </p><p> Two-sided, full-bandwidth spectra of even
 length <i>N</i> (<i>nFull</i> = <i>N</i> even, <i>narrow</i> = <i>false</i>, <i>twoSided</i> = <i>true</i>):<br> The
 frequency corresponding to the index <i>k</i> contained in the interval [0, <i>N</i>/2-1] is <i>k</i> *
 <i>resolution</i>; the frequency corresponding to index <i>k</i> in [<i>N</i>/2, <i>N</i>-1] is (<i>k</i> - <i>N</i>)
 * <i>resolution</i>. Thus, the highest absolute value of the frequency is associated with <i>k</i> = <i>N</i>/2. This
 frequency is -(<i>N</i>/2) * <i>resolution</i>, and it is called the Nyquist frequency. It should be equal to
 -<i>highestFrequency</i>. This is a consistency check. For even <i>N</i>, the spectral amplitude at this largest
 negative frequency is the same as that which could be associated with the largest positive frequency, +(<i>N</i>/2) *
 <i>resolution</i>. If this spectrum was or could have been derived as a Fourier transform of a real data set, then
 the data values at indices <i>k</i> and <i>N</i>-<i>k</i> are equal to one another. Such a real spectrum can be
 converted to a one-sided representation without the loss of information. </p><p> Two-sided, full-bandwidth spectra of
 odd length <i>N</i> (<i>nFull</i> = <i>N</i> odd, <i>narrow</i> = <i>false</i>, <i>twoSided</i> = <i>true</i>): <br>
 The frequency corresponding to the index <i>k</i> contained in the interval [0, (<i>N</i>-1)/2] is <i>k</i> *
 <i>resolution</i>; the frequency corresponding to index <i>k</i> in [(<i>N</i>+1)/2, <i>N</i>-1] is (<i>k</i> -
 <i>N</i>) * <i>resolution</i>. Thus, the highest positive frequency is associated with <i>k</i> = (<i>N</i>-1)/2; the
 lowest negative frequency with <i>k</i> = (<i>N</i>+1)/2; both these frequencies have absolute value (<i>N</i>-1)/2 *
 <i>resolution</i>; and this is called the Nyquist frequency. This should equal <i>highestFrequency</i> (this is a
 consistency check). The spectral amplitudes at the lowest and highest-frequency points are generally different when
 <i>N</i> is odd. If this spectrum was or could have been derived as a Fourier transform of a real data set, then the
 data values at indices <i>k</i> and <i>N</i>-<i>k</i> are equal to one another. Such a spectrum can be converted to a
 one-sided representation without the loss of information. </p><p> A one-sided Spectrum includes only non-negative
 frequencies. The data model assumes that the data come from a spectrum that was the transform of a data set
 containing only real values. Thus, values at the negative frequencies that are not represented in the data set will
 be assumed to be equal to the values at the corresponding positive frequencies. Details depend on whether the total
 number of data points in the corresponding two-sided spectrum was even or odd. For transforms of real data, one-sided
 representations are preferable because they require only about half the memory of two-sided representations, and they
 nevertheless contain the same information. </p><p> One-sided, full-bandwidth spectra of length <i>N</i> derived from
 a two-sided spectrum with an even number of elements (<i>nFull</i> even, <i>narrow</i> = <i>false</i>,
 <i>twoSided</i> = <i>false</i>):<br> In a one-sided spectrum containing <i>N</i> data points, the frequency
 corresponding to element <i>k</i> contained in [0, <i>N</i>-1] is <i>k</i> * <i>resolution</i>. The highest such
 frequency is (<i>N</i>-1) * <i>resolution</i>, and this should be equal to <i>highestFrequency</i>. This is a
 consistency check. For this case, where <i>nFull</i> is even, the original spectrum (or time-series) must have
 contained 2*<i>N</i>-2 points. This should be the value of <i>nFull</i>, and this is a further consistency check. The
 highest-frequency element of the current data set (index <i>N</i>-1) contains the value of the original spectrum at
 its highest frequency (index <i>N</i>-1 in that set). Thus a two-sided full-bandwidth spectrum derived from real data
 of length <i>nFull</i> = 2*<i>N</i>-2 can be converted to a one-sided spectrum just by extracting the first <i>N</i>
 elements. </p><p> One-sided, full-bandwidth spectra of length <i>N</i> derived from a two-sided spectrum with an odd
 number of elements (<i>nFull</i> odd, <i>narrow</i> = <i>false</i>, <i>twoSided</i> = <i>false</i>):<br> In a
 one-sided spectrum containing <i>N</i> data points, the frequency corresponding to element <i>k</i> contained in [0,
 <i>N</i>-1] is <i>k</i> * <i>resolution</i>. The highest such frequency is (<i>N</i>-1) * <i>resolution</i>, and this
 should be equal to <i>highestFrequency</i>. This is a consistency check. For this case, where <i>nFull</i> is odd,
 the original spectrum (or time-series) must have contained 2*<i>N</i> - 1 points. This should be the value of
 <i>nFull</i>, and this is a further consistency check. The highest-frequency element of the current data set (index
 <i>N</i>-1) contains the value of the original spectrum at its highest frequency (index <i>N</i>-1 in that set). A
 two-sided full-bandwidth spectrum derived from real data of length <i>nFull</i> = 2*<i>N</i>-1 can be converted to a
 one-sided spectrum just by extracting the first <i>N</i> elements. </p><p> The Triana spectral data model allows for
 the bandwidth of the data to be narrower than that of the set from which it was derived, and the parameter
 <i>highestFrequency</i> is included in this class mainly to indicate the value of the upper edge of the frequency
 band. The lower edge can be deduced from the other data, such as the number of points and <i>resolution</i>. The
 Triana data storage model for narrow-band spectra places certain restrictions on the way such spectra can be
 constructed, so as (in the case of ComplexSpectrum data sets) to preserve as much as possible of the information
 needed to invert the spectrum back to a time-series. <p/> Two-sided, narrow-band spectra of length <i>N</i> derived
 from a two-sided spectrum with an even number of elements (<i>nFull</i> even, <i>narrow</i> = <i>true</i>,
 <i>twoSided</i> = <i>true</i>):<br> Two-sided narrow-band data must always contain data points for related positive
 and negative frequencies. Removing the upper part of the spectrum requires removing the single highest-frequency
 value and then pairs of values for the contiguous frequencies (each pair being a frequency and its negative), i.e.
 removing in total an odd number of data points. Removing the lower part of the spectrum similarly requires removing
 an odd number of data points. Since the original data set had an even number of elements, we can determine the nature
 of the bandwidth of the narrow-band spectrum as follows. If <i>N</i> (actual number of elements) is even, then the
 band has been shrunk from both sides; the lower frequency limit is <i>highestFrequency</i> - (<i>N</i>/2 - 1) *
 <i>resolution</i> and should not be zero. The whole original frequency range can be reconstructed from these numbers
 and <i>nFull</i>. If <i>N</i> is odd, then either the highest original frequency or the lowest is still present in
 the band; if the highest is still present then <i>highestFrequency</i> = <i>nFull</i>/2 * <i>resolution</i>; if the
 lowest is still present than the lower frequency limit in this case, <i>highestFrequency</i> - ( (<i>N</i>-1)/2 ) *
 <i>resolution</i>, must be zero. A consistency test is that one of these conditions must hold if <i>N</i> is odd.
 </p><p> Two-sided, narrow-band spectra of length <i>N</i> derived from a two-sided spectrum with an odd number of
 elements (<i>nFull</i> odd, <i>narrow</i> = <i>true</i>, <i>twoSided</i> = <i>true</i>):<br> Two-sided narrow-band
 data must always contain data points for related positive and negative frequencies. Removing the lower part of the
 spectrum requires removing the single zero-frequency value and then pairs of values for the contiguous frequencies
 (each pair being a frequency and its negative), i.e. removing in total an odd number of data points. This will make
 <i>N</i> (the actual number of elements) even. Removing the upper part of the spectrum or a portion in the middle
 requires removing an even number of data points in frequency pairs. This will make <i>N</i> odd. Therefore, if
 <i>N</i> is even, the lower part of the spectrum has been removed, and the upper part may or may not have been
 removed. In this case, if <i>highestFrequency</i> = (<i>nFull</i>-1)/2 * <i>resolution</i>, then the upper part of
 the original band is still present. If <i>N</i> is odd, then the lower part of the spectrum is still present and the
 upper has been removed. </p><p> One-sided narrow-band spectra of length <i>N</i> derived from a two-sided spectrum
 with an even number of elements (<i>nFull</i> even, <i>narrow</i> = <i>true</i>, <i>twoSided</i> = <i>false</i>):<br>
 A one-sided spectrum is assumed derived from a two-sided spectrum that came from a Fourier transform of a real data
 set. This is then made narrow-band by removing frequencies at the lower and/or upper ends of the full band. If
 <i>highestFrequency</i> = <i>nFull</i>/2 * <i>resolution</i>, then the top of the band is still present, and (for
 consistency) the highest-frequency data value should be real. The lower frequency limit is <i>highestFrequency</i> -
 (<i>N</i>-1) * <i>resolution</i>, and this should be larger than zero. If the top of the band is missing, then one
 can calculate the lower frequency limit as above; if this is zero then the bottom of the band is still present, and
 the lowest-frequency data value should be real (consistency again). If the lower frequency limit is positive, then
 the bottom of the band is missing. </p><p> One-sided narrow-band spectra of length <i>N</i> derived from a two-sided
 spectrum with an odd number of elements (<i>nFull</i> odd, <i>narrow</i> = <i>true</i>, <i>twoSided</i> =
 <i>false</i>):<br> A one-sided spectrum is assumed derived from a two-sided spectrum that came from a Fourier
 transform of a real data set. This is then made narrow-band by removing frequencies at the lower and/or upper ends of
 the full band. If <i>highestFrequency</i> = (<i>nFull</i>-1)/2 * <i>resolution</i>, then the top of the band is still
 present. The lower frequency limit is <i>highestFrequency</i> - (<i>N</i>-1) * <i>resolution</i>, and this should be
 larger than zero. If the top of the band is missing, then one can calculate the lower frequency limit as above; if
 this is zero then the bottom of the band is still present. If the lower frequency limit is positive, then the bottom
 of the band is missing. </p><p> Spectrum contains a number of methods for accessing and modifying these parameters.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../triana/types/Spectral.html" title="interface in triana.types"><code>Spectral</code></a>, 
<a href="../../triana/types/SampleSet.html" title="class in triana.types"><code>SampleSet</code></a>, 
<a href="../../triana/types/ComplexSpectrum.html" title="class in triana.types"><code>ComplexSpectrum</code></a>, 
<a href="../../triana/types/util/Triplet.html" title="class in triana.types.util"><code>Triplet</code></a>, 
<a href="../../serialized-form.html#triana.types.Spectrum">Serialized Form</a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double[]</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#data">data</a></strong></code>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#frequencyResolution">frequencyResolution</a></strong></code>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#samplingFrequency">samplingFrequency</a></strong></code>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="fields_inherited_from_class_triana.types.VectorType">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;triana.types.<a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></h3>
<code><a href="../../triana/types/VectorType.html#x">x</a>, <a href="../../triana/types/VectorType.html#xlabel">xlabel</a>, <a href="../../triana/types/VectorType.html#y">y</a>, <a href="../../triana/types/VectorType.html#ylabel">ylabel</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="fields_inherited_from_class_triana.types.TrianaType">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;triana.types.<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a></h3>
<code><a href="../../triana/types/TrianaType.html#NOT_CONNECTED">NOT_CONNECTED</a>, <a href="../../triana/types/TrianaType.html#NOT_READY">NOT_READY</a>, <a href="../../triana/types/TrianaType.html#OUT_OF_RANGE">OUT_OF_RANGE</a></code></li>
</ul>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum()">Spectrum</a></strong>()</code>
<div class="block">Create and empty Spectrum with no parameters set.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum(boolean, boolean, double[], double[], int, double, double)">Spectrum</a></strong>(boolean&nbsp;ts,
        boolean&nbsp;nrw,
        double[]&nbsp;real,
        double[]&nbsp;imag,
        int&nbsp;nOrig,
        double&nbsp;df,
        double&nbsp;hf)</code>
<div class="block">Creates a new complex Spectrum with arguments giving the sidedness, whether it is narrow-band or broad-band, the
 data arrays, the number of points in the original broad-band spectrum, the frequency resolution, and the highest
 frequency in the current spectrum.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum(boolean, boolean, double[], int, double, double)">Spectrum</a></strong>(boolean&nbsp;ts,
        boolean&nbsp;nrw,
        double[]&nbsp;data,
        int&nbsp;nOrig,
        double&nbsp;df,
        double&nbsp;hf)</code>
<div class="block">Creates a new real Spectrum with arguments giving the sidedness, whether it is narrow-band or broad-band, the
 data array, the number of points in the original broad-band spectrum, the frequency resolution, and the highest
 frequency in the current spectrum.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum(boolean, boolean, int, int, double, double)">Spectrum</a></strong>(boolean&nbsp;ts,
        boolean&nbsp;nrw,
        int&nbsp;len,
        int&nbsp;nOrig,
        double&nbsp;df,
        double&nbsp;hf)</code>
<div class="block">Creates a new Spectrum with arguments giving the sidedness, whether it is narrow-band or broad-band, the data
 length, the number of points in the original broad-band spectrum, the frequency resolution, and the highest
 frequency in the current spectrum.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum(boolean, double[], double[], int, double)">Spectrum</a></strong>(boolean&nbsp;ts,
        double[]&nbsp;real,
        double[]&nbsp;imag,
        int&nbsp;nOrig,
        double&nbsp;df)</code>
<div class="block">Creates a new complex Spectrum with given sidedness, data arrays, number of points in the two-sided spectrum, and
 frequency resolution.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum(boolean, double[], int, double)">Spectrum</a></strong>(boolean&nbsp;ts,
        double[]&nbsp;data,
        int&nbsp;nOrig,
        double&nbsp;df)</code>
<div class="block">Creates a new real Spectrum with given sidedness, data arrays, number of points in the two-sided spectrum, and
 frequency resolution.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum(boolean, int, double)">Spectrum</a></strong>(boolean&nbsp;ts,
        int&nbsp;nOrig,
        double&nbsp;df)</code>
<div class="block">Creates a new Spectrum with a given sidedness, number of points that there would be in the two-sided spectrum,
 and frequency resolution.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum(triana.types.ComplexSpectrum)">Spectrum</a></strong>(<a href="../../triana/types/ComplexSpectrum.html" title="class in triana.types">ComplexSpectrum</a>&nbsp;cs)</code>
<div class="block">Creates a Spectrum from a ComplexSpectrum by keeping only the real part of the data.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum(triana.types.ComplexSpectrum, boolean)">Spectrum</a></strong>(<a href="../../triana/types/ComplexSpectrum.html" title="class in triana.types">ComplexSpectrum</a>&nbsp;cs,
        boolean&nbsp;copy)</code>
<div class="block">Creates a Spectrum from a ComplexSpectrum by keeping only the real part of the data.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum(double, double[])">Spectrum</a></strong>(double&nbsp;samplingFrequency,
        double[]&nbsp;data)</code>
<div class="block">Obsolete Constructor that creates a new one-sided Spectrum with a certain sampling frequency and the actual
 allocated data.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../triana/types/Spectrum.html#Spectrum(double, int)">Spectrum</a></strong>(double&nbsp;sf,
        int&nbsp;points)</code>
<div class="block">This is an obsolete Constructor that will be eliminated when possible.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a></code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#copyMe()">copyMe</a></strong>()</code>
<div class="block">This is one of the most important methods of Triana data.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#copyParameters(triana.types.TrianaType)">copyParameters</a></strong>(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;source)</code>
<div class="block">Copies modifiable parameters from the argument object to the current object.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#equals(triana.types.TrianaType)">equals</a></strong>(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;obj)</code>
<div class="block">Determines whether the argument TrianaType is equal to the current Spectrum.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#extendWithZeros(int, boolean)">extendWithZeros</a></strong>(int&nbsp;newLength,
               boolean&nbsp;front)</code>
<div class="block">Extends the data set to a longer set by padding with zeros, keeping the frequency resolution unchanged.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#frequencyResolution()">frequencyResolution</a></strong>()</code>
<div class="block">Obsolete method for obtaining frequency resolution.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getFrequencyArray(int)">getFrequencyArray</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the frequency values of the independent data points for the given dimension, in the order of lowest
 frequency to highest, regardless of how the data are stored internally.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getFrequencyResolution()">getFrequencyResolution</a></strong>()</code>
<div class="block">Returns the frequency resolution of the data.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getFrequencyResolution(int)">getFrequencyResolution</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the frequency resolution of the data in the independent dimension <i>dim</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getGraphArrayImag(int)">getGraphArrayImag</a></strong>(int&nbsp;dv)</code>
<div class="block">Returns the imaginary part of the dependent variable ordered so that the frequency values all run monotonically
 upwards.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getGraphArrayReal(int)">getGraphArrayReal</a></strong>(int&nbsp;dv)</code>
<div class="block">Returns the real part of the dependent variable ordered so that the frequency values all run monotonically
 upwards.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double[]</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getIndependentScaleImag(int)">getIndependentScaleImag</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns null because the data is real.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double[]</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getIndependentScaleReal(int)">getIndependentScaleReal</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the independent data scaled the way they should be graphed.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getLowerFrequencyBound()">getLowerFrequencyBound</a></strong>()</code>
<div class="block">Returns the (non-negative) value of the lowest frequency in the frequency band held in the object.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getLowerFrequencyBound(int)">getLowerFrequencyBound</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the (non-negative) value of the lowest frequency in the frequency band held in the object, for the given
 direction <i>dim</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getNyquist()">getNyquist</a></strong>()</code>
<div class="block">Returns the Nyquist frequency, defined to be the highest frequency that this data set could contain if it were
 not narrow-banded.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getOrderedSpectrumImag()">getOrderedSpectrumImag</a></strong>()</code>
<div class="block">Returns the imaginary parts of the values of the spectrum (data points) in a multidimensional array, ordered so
 that in each dimension the values correspond to frequencies running from the lowest to the highest, regardless of
 the internal data model.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getOrderedSpectrumReal()">getOrderedSpectrumReal</a></strong>()</code>
<div class="block">Returns the real parts of the values of the spectrum (data points) in a multidimensional array, ordered so that
 in each dimension the values correspond to frequencies running from the lowest to the highest, regardless of the
 internal data model.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getOriginalN()">getOriginalN</a></strong>()</code>
<div class="block">Returns the number of points in the data set whose transform could have led to the present data, or equivalently
 the number of points in the two-sided full-bandwidth spectrum from which the present spectrum could have been
 derived.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getOriginalN(int)">getOriginalN</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the number of points in the data set in the dimension <i>dim</i> whose transform could have led to the
 present data, or equivalently the number of points in the two-sided full-bandwidth spectrum from which the
 present spectrum could have been derived.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getSamplingRate()">getSamplingRate</a></strong>()</code>
<div class="block">Returns the sampling frequency that a time-series would have had if it had led to the present spectral data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getUpperFrequencyBound()">getUpperFrequencyBound</a></strong>()</code>
<div class="block">Returns the (non-negative) value of the highest frequency in the frequency band held in the object.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#getUpperFrequencyBound(int)">getUpperFrequencyBound</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns the (non-negative) value of the highest frequency in the frequency band held in the object, for the given
 direction <i>dim</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#inputFromStream(java.io.BufferedReader)">inputFromStream</a></strong>(java.io.BufferedReader&nbsp;dis)</code>
<div class="block">Used when Triana types want to be able to receive ASCII data from the output of other programs.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#interpolateZeros(int, boolean)">interpolateZeros</a></strong>(int&nbsp;factor,
                boolean&nbsp;before)</code>
<div class="block">Inserts zeros in between existing elements of the data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#isCompatible(triana.types.TrianaType)">isCompatible</a></strong>(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;obj)</code>
<div class="block">Tests the argument object to determine if it makes sense to perform arithmetic operations between it and the
 current object.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#isNarrow()">isNarrow</a></strong>()</code>
<div class="block">Returns <i>true</i> if the data represent a narrow bandwidth derived from a full-band spectrum.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#isNarrow(int)">isNarrow</a></strong>(int&nbsp;dim)</code>
<div class="block">Returns <i>true</i> if the data represent a narrow bandwidth derived from a full-band spectrum in the independent
 dimension <i>dim</i>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#isTwoSided()">isTwoSided</a></strong>()</code>
<div class="block">Returns <i>true</i> if the data are stored as a two-sided transform, <i>i.e.</i> containing both the positive and
 negative frequency data.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#outputToStream(java.io.PrintWriter)">outputToStream</a></strong>(java.io.PrintWriter&nbsp;dos)</code>
<div class="block">Used when Triana types want to be able to send ASCII data to other programs using strings.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#points()">points</a></strong>()</code>
<div class="block">Obsolete method for obtaining the number of data points.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../triana/types/Spectrum.html" title="class in triana.types">Spectrum</a></code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#reduceNyquist(triana.types.Spectrum, boolean)">reduceNyquist</a></strong>(<a href="../../triana/types/Spectrum.html" title="class in triana.types">Spectrum</a>&nbsp;inputNarrow,
             boolean&nbsp;allocMem)</code>
<div class="block">Class method that takes an input narrow-band Spectrum and reduces <i>nFull</i> to be compatible with the upper
 frequency bound, so that the set is no longer narrow-band at the top.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#samplingFrequency()">samplingFrequency</a></strong>()</code>
<div class="block">Obsolete method for obtaining sampling frequency.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#setDefaultAxisLabelling()">setDefaultAxisLabelling</a></strong>()</code>
<div class="block">Added by I.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#setFrequencyResolution(double)">setFrequencyResolution</a></strong>(double&nbsp;df)</code>
<div class="block">Sets the frequency resolution of the data.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#setFrequencyResolution(double, int)">setFrequencyResolution</a></strong>(double&nbsp;f,
                      int&nbsp;dim)</code>
<div class="block">Sets the frequency resolution of the data in the independent dimension <i>dim</i>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#setNarrow(boolean)">setNarrow</a></strong>(boolean&nbsp;n)</code>
<div class="block">Sets the narrow-band flag to the value of the argument.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#setNarrow(boolean, int)">setNarrow</a></strong>(boolean&nbsp;n,
         int&nbsp;dim)</code>
<div class="block">Sets the narrow-band flag associated with the independent dimension <i>dim</i> (second argument) to the value of
 the first argument.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#setOriginalN(int)">setOriginalN</a></strong>(int&nbsp;nOrig)</code>
<div class="block">Sets to the given argument the number of points in the data set whose transform could have led to the present
 data, or equivalently the number of points in the two-sided full-bandwidth spectrum from which the present
 spectrum could have been derived.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#setOriginalN(int, int)">setOriginalN</a></strong>(int&nbsp;nOrig,
            int&nbsp;dim)</code>
<div class="block">Sets to the given first argument <i>nOrig</i> the number of points in the data set in the dimension given by the
 second argument <i>dim</i> whose transform could have led to the present data, or equivalently the number of
 points in the two-sided full-bandwidth spectrum from which the present spectrum could have been derived.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#setTwoSided(boolean)">setTwoSided</a></strong>(boolean&nbsp;s)</code>
<div class="block">Sets the two-sidedness flag to the value of the argument, <i>true</i> if the data are two-sided.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#setUpperFrequencyBound(double)">setUpperFrequencyBound</a></strong>(double&nbsp;hf)</code>
<div class="block">Sets the (non-negative) value of the highest frequency in the frequency band held in the object to the given
 value.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#setUpperFrequencyBound(double, int)">setUpperFrequencyBound</a></strong>(double&nbsp;hf,
                      int&nbsp;dim)</code>
<div class="block">Sets or resets the (non-negative) value of the highest frequency in the frequency band held in the object for the
 given direction <i>dim</i> to the given value <i>hf</i>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../triana/types/Spectrum.html#updateObsoletePointers()">updateObsoletePointers</a></strong>()</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_triana.types.VectorType">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;triana.types.<a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></h3>
<code><a href="../../triana/types/VectorType.html#getData()">getData</a>, <a href="../../triana/types/VectorType.html#getDataImag()">getDataImag</a>, <a href="../../triana/types/VectorType.html#getDataReal()">getDataReal</a>, <a href="../../triana/types/VectorType.html#getGraph()">getGraph</a>, <a href="../../triana/types/VectorType.html#getGraphImag()">getGraphImag</a>, <a href="../../triana/types/VectorType.html#getGraphReal()">getGraphReal</a>, <a href="../../triana/types/VectorType.html#getScale()">getScale</a>, <a href="../../triana/types/VectorType.html#getScaleImag()">getScaleImag</a>, <a href="../../triana/types/VectorType.html#getScaleReal()">getScaleReal</a>, <a href="../../triana/types/VectorType.html#getXArray()">getXArray</a>, <a href="../../triana/types/VectorType.html#getXImag()">getXImag</a>, <a href="../../triana/types/VectorType.html#getXReal()">getXReal</a>, <a href="../../triana/types/VectorType.html#getXTriplet()">getXTriplet</a>, <a href="../../triana/types/VectorType.html#initialiseData()">initialiseData</a>, <a href="../../triana/types/VectorType.html#initialiseDataComplex(int)">initialiseDataComplex</a>, <a href="../../triana/types/VectorType.html#initialiseDataReal(int)">initialiseDataReal</a>, <a href="../../triana/types/VectorType.html#isTriplet()">isTriplet</a>, <a href="../../triana/types/VectorType.html#isUniform()">isUniform</a>, <a href="../../triana/types/VectorType.html#length()">length</a>, <a href="../../triana/types/VectorType.html#setData(double[])">setData</a>, <a href="../../triana/types/VectorType.html#setData(double[], double[])">setData</a>, <a href="../../triana/types/VectorType.html#setDataImag(double[])">setDataImag</a>, <a href="../../triana/types/VectorType.html#setDataReal(double[])">setDataReal</a>, <a href="../../triana/types/VectorType.html#setX(double[])">setX</a>, <a href="../../triana/types/VectorType.html#setX(double[], double[])">setX</a>, <a href="../../triana/types/VectorType.html#setX(triana.types.util.Triplet)">setX</a>, <a href="../../triana/types/VectorType.html#setXImag(double[])">setXImag</a>, <a href="../../triana/types/VectorType.html#setXReal(double[])">setXReal</a>, <a href="../../triana/types/VectorType.html#size()">size</a>, <a href="../../triana/types/VectorType.html#testDataModel()">testDataModel</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_triana.types.GraphType">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;triana.types.<a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></h3>
<code><a href="../../triana/types/GraphType.html#add(java.lang.Object)">add</a>, <a href="../../triana/types/GraphType.html#addToTitle(java.lang.String)">addToTitle</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToBytes()">convertDependentDataArraysToBytes</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToDoubles()">convertDependentDataArraysToDoubles</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToFloats()">convertDependentDataArraysToFloats</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToInts()">convertDependentDataArraysToInts</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToLongs()">convertDependentDataArraysToLongs</a>, <a href="../../triana/types/GraphType.html#convertDependentDataArraysToShorts()">convertDependentDataArraysToShorts</a>, <a href="../../triana/types/GraphType.html#copyData(triana.types.TrianaType)">copyData</a>, <a href="../../triana/types/GraphType.html#copyLabels()">copyLabels</a>, <a href="../../triana/types/GraphType.html#divide(java.lang.Object)">divide</a>, <a href="../../triana/types/GraphType.html#equals(java.lang.Object)">equals</a>, <a href="../../triana/types/GraphType.html#getDataArrayClass(int)">getDataArrayClass</a>, <a href="../../triana/types/GraphType.html#getDataArrayImag(int)">getDataArrayImag</a>, <a href="../../triana/types/GraphType.html#getDataArrayImag(int, java.lang.Class)">getDataArrayImag</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsBytes(int)">getDataArrayImagAsBytes</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsDoubles(int)">getDataArrayImagAsDoubles</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsFloats(int)">getDataArrayImagAsFloats</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsInts(int)">getDataArrayImagAsInts</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsLongs(int)">getDataArrayImagAsLongs</a>, <a href="../../triana/types/GraphType.html#getDataArrayImagAsShorts(int)">getDataArrayImagAsShorts</a>, <a href="../../triana/types/GraphType.html#getDataArrayReal(int)">getDataArrayReal</a>, <a href="../../triana/types/GraphType.html#getDataArrayReal(int, java.lang.Class)">getDataArrayReal</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsBytes(int)">getDataArrayRealAsBytes</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsDoubles(int)">getDataArrayRealAsDoubles</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsFloats(int)">getDataArrayRealAsFloats</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsInts(int)">getDataArrayRealAsInts</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsLongs(int)">getDataArrayRealAsLongs</a>, <a href="../../triana/types/GraphType.html#getDataArrayRealAsShorts(int)">getDataArrayRealAsShorts</a>, <a href="../../triana/types/GraphType.html#getDataArrayTypeNames(int)">getDataArrayTypeNames</a>, <a href="../../triana/types/GraphType.html#getDependentLabels(int)">getDependentLabels</a>, <a href="../../triana/types/GraphType.html#getDependentVariableDimensions(int)">getDependentVariableDimensions</a>, <a href="../../triana/types/GraphType.html#getDependentVariables()">getDependentVariables</a>, <a href="../../triana/types/GraphType.html#getDimensionLengths()">getDimensionLengths</a>, <a href="../../triana/types/GraphType.html#getDimensionLengths(int)">getDimensionLengths</a>, <a href="../../triana/types/GraphType.html#getGraphArrayImagLog10(int)">getGraphArrayImagLog10</a>, <a href="../../triana/types/GraphType.html#getGraphArrayRealLog10(int)">getGraphArrayRealLog10</a>, <a href="../../triana/types/GraphType.html#getIndependentArrayImag(int)">getIndependentArrayImag</a>, <a href="../../triana/types/GraphType.html#getIndependentArrayReal(int)">getIndependentArrayReal</a>, <a href="../../triana/types/GraphType.html#getIndependentLabels(int)">getIndependentLabels</a>, <a href="../../triana/types/GraphType.html#getIndependentScaleImagLog10(int)">getIndependentScaleImagLog10</a>, <a href="../../triana/types/GraphType.html#getIndependentScaleRealLog10(int)">getIndependentScaleRealLog10</a>, <a href="../../triana/types/GraphType.html#getIndependentTriplet(int)">getIndependentTriplet</a>, <a href="../../triana/types/GraphType.html#getIndependentVariables()">getIndependentVariables</a>, <a href="../../triana/types/GraphType.html#getLabels()">getLabels</a>, <a href="../../triana/types/GraphType.html#getLabelsColumn()">getLabelsColumn</a>, <a href="../../triana/types/GraphType.html#getTitle()">getTitle</a>, <a href="../../triana/types/GraphType.html#isArithmeticArray(int)">isArithmeticArray</a>, <a href="../../triana/types/GraphType.html#isArithmeticData(int)">isArithmeticData</a>, <a href="../../triana/types/GraphType.html#isCompatible(java.lang.Object)">isCompatible</a>, <a href="../../triana/types/GraphType.html#isDependentComplex(int)">isDependentComplex</a>, <a href="../../triana/types/GraphType.html#isIndependentComplex(int)">isIndependentComplex</a>, <a href="../../triana/types/GraphType.html#isPrimitiveArray(int)">isPrimitiveArray</a>, <a href="../../triana/types/GraphType.html#isPrimitiveData(int)">isPrimitiveData</a>, <a href="../../triana/types/GraphType.html#isTriplet(int)">isTriplet</a>, <a href="../../triana/types/GraphType.html#isUniform(int)">isUniform</a>, <a href="../../triana/types/GraphType.html#maxDependentGraphingValuesImag()">maxDependentGraphingValuesImag</a>, <a href="../../triana/types/GraphType.html#maxDependentGraphingValuesReal()">maxDependentGraphingValuesReal</a>, <a href="../../triana/types/GraphType.html#maxDependentVariablesImag()">maxDependentVariablesImag</a>, <a href="../../triana/types/GraphType.html#maxDependentVariablesReal()">maxDependentVariablesReal</a>, <a href="../../triana/types/GraphType.html#maxIndependentScalesImag()">maxIndependentScalesImag</a>, <a href="../../triana/types/GraphType.html#maxIndependentScalesReal()">maxIndependentScalesReal</a>, <a href="../../triana/types/GraphType.html#maxIndependentVariablesImag()">maxIndependentVariablesImag</a>, <a href="../../triana/types/GraphType.html#maxIndependentVariablesReal()">maxIndependentVariablesReal</a>, <a href="../../triana/types/GraphType.html#minDependentGraphingValuesImag()">minDependentGraphingValuesImag</a>, <a href="../../triana/types/GraphType.html#minDependentGraphingValuesReal()">minDependentGraphingValuesReal</a>, <a href="../../triana/types/GraphType.html#minDependentVariablesImag()">minDependentVariablesImag</a>, <a href="../../triana/types/GraphType.html#minDependentVariablesReal()">minDependentVariablesReal</a>, <a href="../../triana/types/GraphType.html#minIndependentScalesImag()">minIndependentScalesImag</a>, <a href="../../triana/types/GraphType.html#minIndependentScalesReal()">minIndependentScalesReal</a>, <a href="../../triana/types/GraphType.html#minIndependentVariablesImag()">minIndependentVariablesImag</a>, <a href="../../triana/types/GraphType.html#minIndependentVariablesReal()">minIndependentVariablesReal</a>, <a href="../../triana/types/GraphType.html#multiply(java.lang.Object)">multiply</a>, <a href="../../triana/types/GraphType.html#resetDependent(int)">resetDependent</a>, <a href="../../triana/types/GraphType.html#resetIndependent(int)">resetIndependent</a>, <a href="../../triana/types/GraphType.html#restrictToSubdomain(int, double, double)">restrictToSubdomain</a>, <a href="../../triana/types/GraphType.html#restrictToSubdomain(int, int, int)">restrictToSubdomain</a>, <a href="../../triana/types/GraphType.html#setDataArrayImag(java.lang.Object, int)">setDataArrayImag</a>, <a href="../../triana/types/GraphType.html#setDataArrayReal(java.lang.Object, int)">setDataArrayReal</a>, <a href="../../triana/types/GraphType.html#setDependentLabels(int, java.lang.String)">setDependentLabels</a>, <a href="../../triana/types/GraphType.html#setDependentVariableDimensions(int[], int)">setDependentVariableDimensions</a>, <a href="../../triana/types/GraphType.html#setDimensionLengths(int[])">setDimensionLengths</a>, <a href="../../triana/types/GraphType.html#setDimensionLengths(int, int)">setDimensionLengths</a>, <a href="../../triana/types/GraphType.html#setDimensions(int, int)">setDimensions</a>, <a href="../../triana/types/GraphType.html#setIndependentArrayImag(double[], int)">setIndependentArrayImag</a>, <a href="../../triana/types/GraphType.html#setIndependentArrayReal(double[], int)">setIndependentArrayReal</a>, <a href="../../triana/types/GraphType.html#setIndependentLabels(int, java.lang.String)">setIndependentLabels</a>, <a href="../../triana/types/GraphType.html#setIndependentTriplet(int, double, double, int)">setIndependentTriplet</a>, <a href="../../triana/types/GraphType.html#setIndependentTriplet(triana.types.util.Triplet, int)">setIndependentTriplet</a>, <a href="../../triana/types/GraphType.html#setLabels(java.util.Hashtable)">setLabels</a>, <a href="../../triana/types/GraphType.html#setTitle(java.lang.String)">setTitle</a>, <a href="../../triana/types/GraphType.html#subtract(java.lang.Object)">subtract</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_triana.types.TrianaType">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;triana.types.<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a></h3>
<code><a href="../../triana/types/TrianaType.html#containerSize()">containerSize</a>, <a href="../../triana/types/TrianaType.html#dataExists(java.lang.Object)">dataExists</a>, <a href="../../triana/types/TrianaType.html#deleteFromContainer(java.lang.Object)">deleteFromContainer</a>, <a href="../../triana/types/TrianaType.html#getDataContainer()">getDataContainer</a>, <a href="../../triana/types/TrianaType.html#getFromContainer(java.lang.Object)">getFromContainer</a>, <a href="../../triana/types/TrianaType.html#getSequenceNumber()">getSequenceNumber</a>, <a href="../../triana/types/TrianaType.html#insertIntoContainer(java.lang.Object, java.lang.Object)">insertIntoContainer</a>, <a href="../../triana/types/TrianaType.html#inspectDataContainer()">inspectDataContainer</a>, <a href="../../triana/types/TrianaType.html#setDataContainer(java.util.Hashtable)">setDataContainer</a>, <a href="../../triana/types/TrianaType.html#setSequenceNumber(int)">setSequenceNumber</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="samplingFrequency">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>samplingFrequency</h4>
<pre>public&nbsp;double samplingFrequency</pre>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete. It must be kept to the
 right values by the <i>updateObsoletePointers</i> method and/or constructors and <i>set...</i> methods.) </p><p>
 The sampling frequency -- this will not be supported in later versions, since it is part of the Signal interface
 and not the Spectral interface.</div>
</li>
</ul>
<a name="frequencyResolution">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>frequencyResolution</h4>
<pre>public&nbsp;double frequencyResolution</pre>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete. It must be kept to the
 right values by the <i>updateObsoletePointers</i> method and/or constructors and <i>set...</i> methods.) </p><p>
 The frequency resolution -- this is obsolete because it is public, and has been replaced by the private parameter
 <i>resolution</i>. Constructors and methods ensure that this is kept equal to <i>resolution</i>.</div>
</li>
</ul>
<a name="data">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>data</h4>
<pre>public&nbsp;double[] data</pre>
<div class="block">(Parameter that is kept for consistency with previous versions, but which is obsolete. It must be kept to the
 right values by the <i>updateObsoletePointers</i> method and/or constructors and <i>set...</i> methods.) </p><p>
 The signal data, a pointer which is kept pointing at the appropriate location in <i>dataContainer</i>.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Spectrum()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum()</pre>
<div class="block">Create and empty Spectrum with no parameters set.</div>
</li>
</ul>
<a name="Spectrum(double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum(double&nbsp;sf,
        int&nbsp;points)</pre>
<div class="block">This is an obsolete Constructor that will be eliminated when possible. It uses <i>samplingFrequency</i>, a
 parameter that is obsolete. It is distinguished from the constructors that should now be used by not having a
 boolean argument. This Constructor creates a new one-sided Spectrum with a certain sampling frequency and number
 of points. It also allocates memory for the data but does not initialise it.  Use method <i>initialiseData</i> to
 set all elements to zero.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sf</code> - is the sampling frequency</dd><dd><code>points</code> - is the number of points</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../triana/types/VectorType.html#initialiseData()"><code>VectorType.initialiseData()</code></a></dd></dl>
</li>
</ul>
<a name="Spectrum(double, double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum(double&nbsp;samplingFrequency,
        double[]&nbsp;data)</pre>
<div class="block">Obsolete Constructor that creates a new one-sided Spectrum with a certain sampling frequency and the actual
 allocated data. It uses <i>samplingFrequency</i>, a parameter that is obsolete. It is distinguished from the
 constructors that should now be used by not having a boolean argument.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>samplingFrequency</code> - is the sampling frequency</dd><dd><code>data</code> - the actual allocated data</dd></dl>
</li>
</ul>
<a name="Spectrum(boolean, boolean, int, int, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum(boolean&nbsp;ts,
        boolean&nbsp;nrw,
        int&nbsp;len,
        int&nbsp;nOrig,
        double&nbsp;df,
        double&nbsp;hf)</pre>
<div class="block">Creates a new Spectrum with arguments giving the sidedness, whether it is narrow-band or broad-band, the data
 length, the number of points in the original broad-band spectrum, the frequency resolution, and the highest
 frequency in the current spectrum. It does not allocate data. Various checks are performed on the consistency of
 the input parameters with the Triana spectral storage model, and error messages are printed to
 <i>System.out</i>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ts</code> - <i>True</i> if the new Spectrum is to be two-sided</dd><dd><code>nrw</code> - <i>True</i> if the new Spectrum is to be narrow-band</dd><dd><code>len</code> - Number of points in the current data set</dd><dd><code>nOrig</code> - Number of points in the original two-sided full spectrum</dd><dd><code>df</code> - Frequency resolution</dd><dd><code>hf</code> - Highest frequency in the current data set</dd></dl>
</li>
</ul>
<a name="Spectrum(boolean, boolean, double[], int, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum(boolean&nbsp;ts,
        boolean&nbsp;nrw,
        double[]&nbsp;data,
        int&nbsp;nOrig,
        double&nbsp;df,
        double&nbsp;hf)</pre>
<div class="block">Creates a new real Spectrum with arguments giving the sidedness, whether it is narrow-band or broad-band, the
 data array, the number of points in the original broad-band spectrum, the frequency resolution, and the highest
 frequency in the current spectrum.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ts</code> - <i>True</i> if the new Spectrum is to be two-sided</dd><dd><code>nrw</code> - <i>True</i> if the new Spectrum is to be narrow-band</dd><dd><code>data</code> - The data</dd><dd><code>nOrig</code> - Number of points in the original two-sided full spectrum</dd><dd><code>df</code> - Frequency resolution</dd><dd><code>hf</code> - Highest frequency in the current data set</dd></dl>
</li>
</ul>
<a name="Spectrum(boolean, boolean, double[], double[], int, double, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum(boolean&nbsp;ts,
        boolean&nbsp;nrw,
        double[]&nbsp;real,
        double[]&nbsp;imag,
        int&nbsp;nOrig,
        double&nbsp;df,
        double&nbsp;hf)</pre>
<div class="block">Creates a new complex Spectrum with arguments giving the sidedness, whether it is narrow-band or broad-band, the
 data arrays, the number of points in the original broad-band spectrum, the frequency resolution, and the highest
 frequency in the current spectrum.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ts</code> - <i>True</i> if the new Spectrum is to be two-sided</dd><dd><code>nrw</code> - <i>True</i> if the new Spectrum is to be narrow-band</dd><dd><code>real</code> - Real part of the data</dd><dd><code>imag</code> - Imaginary part of the data</dd><dd><code>nOrig</code> - Number of points in the original two-sided full spectrum</dd><dd><code>df</code> - Frequency resolution</dd><dd><code>hf</code> - Highest frequency in the current data set</dd></dl>
</li>
</ul>
<a name="Spectrum(boolean, int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum(boolean&nbsp;ts,
        int&nbsp;nOrig,
        double&nbsp;df)</pre>
<div class="block">Creates a new Spectrum with a given sidedness, number of points that there would be in the two-sided spectrum,
 and frequency resolution. It does not allocate memory for the data. It assumes that the data are full-bandwidth.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ts</code> - <i>true</i> if the new Spectrum is to be two-sided</dd><dd><code>nOrig</code> - Number of points</dd><dd><code>df</code> - Frequency resolution</dd></dl>
</li>
</ul>
<a name="Spectrum(boolean, double[], int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum(boolean&nbsp;ts,
        double[]&nbsp;data,
        int&nbsp;nOrig,
        double&nbsp;df)</pre>
<div class="block">Creates a new real Spectrum with given sidedness, data arrays, number of points in the two-sided spectrum, and
 frequency resolution. It assumes that the data are full-bandwidth. The lengths of the input data arrays will be
 shorter than the size of the two-sided spectrum if the input is one-sided.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ts</code> - <i>True</i> if the new Spectrum is to be two-sided</dd><dd><code>data</code> - The real part of the input spectrum</dd><dd><code>nOrig</code> - Number of points in the equivalent two-sided spectrum</dd><dd><code>df</code> - Frequency resolution</dd></dl>
</li>
</ul>
<a name="Spectrum(boolean, double[], double[], int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum(boolean&nbsp;ts,
        double[]&nbsp;real,
        double[]&nbsp;imag,
        int&nbsp;nOrig,
        double&nbsp;df)</pre>
<div class="block">Creates a new complex Spectrum with given sidedness, data arrays, number of points in the two-sided spectrum, and
 frequency resolution. It assumes that the data are full-bandwidth. The lengths of the input data arrays will be
 shorter than the size of the two-sided spectrum if the input is one-sided.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>ts</code> - <i>True</i> if the new Spectrum is to be two-sided</dd><dd><code>real</code> - The real part of the input spectrum</dd><dd><code>imag</code> - The imaginary part of the input spectrum</dd><dd><code>nOrig</code> - Number of points in the equivalent two-sided spectrum</dd><dd><code>df</code> - Frequency resolution</dd></dl>
</li>
</ul>
<a name="Spectrum(triana.types.ComplexSpectrum, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum(<a href="../../triana/types/ComplexSpectrum.html" title="class in triana.types">ComplexSpectrum</a>&nbsp;cs,
        boolean&nbsp;copy)</pre>
<div class="block">Creates a Spectrum from a ComplexSpectrum by keeping only the real part of the data. The boolean parameter
 determines whether the data of the new object are copied from the old or simply referenced.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>cs</code> - The input data set</dd><dd><code>copy</code> - True if the new data will be a copy of the old</dd></dl>
</li>
</ul>
<a name="Spectrum(triana.types.ComplexSpectrum)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Spectrum</h4>
<pre>public&nbsp;Spectrum(<a href="../../triana/types/ComplexSpectrum.html" title="class in triana.types">ComplexSpectrum</a>&nbsp;cs)</pre>
<div class="block">Creates a Spectrum from a ComplexSpectrum by keeping only the real part of the data. The data of the new object
 are  simply referenced from the old.</div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="setDefaultAxisLabelling()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setDefaultAxisLabelling</h4>
<pre>public&nbsp;void&nbsp;setDefaultAxisLabelling()</pre>
<div class="block">Added by I. Taylor, August 2001 : This function sets the default labeling scheme used for the axis by this data
 type. All constructors call this function to set default values for the axis.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#setDefaultAxisLabelling()">setDefaultAxisLabelling</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
</dl>
</li>
</ul>
<a name="getFrequencyResolution(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFrequencyResolution</h4>
<pre>public&nbsp;double&nbsp;getFrequencyResolution(int&nbsp;dim)</pre>
<div class="block">Returns the frequency resolution of the data in the independent dimension <i>dim</i>. Because the data are really
 one-dimensional, the dimension argument is ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getFrequencyResolution(int)">getFrequencyResolution</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd>
<dt><span class="strong">Returns:</span></dt><dd>The frequency resolution</dd></dl>
</li>
</ul>
<a name="getFrequencyResolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFrequencyResolution</h4>
<pre>public&nbsp;double&nbsp;getFrequencyResolution()</pre>
<div class="block">Returns the frequency resolution of the data.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>double The frequency resolution</dd></dl>
</li>
</ul>
<a name="setFrequencyResolution(double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFrequencyResolution</h4>
<pre>public&nbsp;void&nbsp;setFrequencyResolution(double&nbsp;f,
                          int&nbsp;dim)</pre>
<div class="block">Sets the frequency resolution of the data in the independent dimension <i>dim</i>. Because the data are
 one-dimensional, <i>dim</i> is ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#setFrequencyResolution(double, int)">setFrequencyResolution</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd><dd><code>f</code> - The frequency resolution</dd></dl>
</li>
</ul>
<a name="setFrequencyResolution(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFrequencyResolution</h4>
<pre>public&nbsp;void&nbsp;setFrequencyResolution(double&nbsp;df)</pre>
<div class="block">Sets the frequency resolution of the data.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>df</code> - The frequency resolution</dd></dl>
</li>
</ul>
<a name="isTwoSided()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isTwoSided</h4>
<pre>public&nbsp;boolean&nbsp;isTwoSided()</pre>
<div class="block">Returns <i>true</i> if the data are stored as a two-sided transform, <i>i.e.</i> containing both the positive and
 negative frequency data. If <i>false</i>, the data are one-sided, containing only positive frequencies.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#isTwoSided()">isTwoSided</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>boolean <i>true</i> if data are two-sided in frequency space</dd></dl>
</li>
</ul>
<a name="setTwoSided(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTwoSided</h4>
<pre>public&nbsp;void&nbsp;setTwoSided(boolean&nbsp;s)</pre>
<div class="block">Sets the two-sidedness flag to the value of the argument, <i>true</i> if the data are two-sided.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#setTwoSided(boolean)">setTwoSided</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>s</code> - <i>true</i> if the data will be two-sided</dd></dl>
</li>
</ul>
<a name="getOriginalN(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOriginalN</h4>
<pre>public&nbsp;int&nbsp;getOriginalN(int&nbsp;dim)</pre>
<div class="block">Returns the number of points in the data set in the dimension <i>dim</i> whose transform could have led to the
 present data, or equivalently the number of points in the two-sided full-bandwidth spectrum from which the
 present spectrum could have been derived. Because the data are one-dimensional, the value of <i>dim</i> is
 ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getOriginalN(int)">getOriginalN</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd>
<dt><span class="strong">Returns:</span></dt><dd>The number of points in the original data set</dd></dl>
</li>
</ul>
<a name="getOriginalN()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOriginalN</h4>
<pre>public&nbsp;int&nbsp;getOriginalN()</pre>
<div class="block">Returns the number of points in the data set whose transform could have led to the present data, or equivalently
 the number of points in the two-sided full-bandwidth spectrum from which the present spectrum could have been
 derived.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>int The number of points in the original data set</dd></dl>
</li>
</ul>
<a name="setOriginalN(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOriginalN</h4>
<pre>public&nbsp;void&nbsp;setOriginalN(int&nbsp;nOrig,
                int&nbsp;dim)</pre>
<div class="block">Sets to the given first argument <i>nOrig</i> the number of points in the data set in the dimension given by the
 second argument <i>dim</i> whose transform could have led to the present data, or equivalently the number of
 points in the two-sided full-bandwidth spectrum from which the present spectrum could have been derived. Because
 the data are one-dimensional, the value of <i>dim</i> is ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#setOriginalN(int, int)">setOriginalN</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd><dd><code>nOrig</code> - The new number of points in the original data set</dd></dl>
</li>
</ul>
<a name="setOriginalN(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOriginalN</h4>
<pre>public&nbsp;void&nbsp;setOriginalN(int&nbsp;nOrig)</pre>
<div class="block">Sets to the given argument the number of points in the data set whose transform could have led to the present
 data, or equivalently the number of points in the two-sided full-bandwidth spectrum from which the present
 spectrum could have been derived.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>nOrig</code> - The new number of points in the original data set</dd></dl>
</li>
</ul>
<a name="isNarrow(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isNarrow</h4>
<pre>public&nbsp;boolean&nbsp;isNarrow(int&nbsp;dim)</pre>
<div class="block">Returns <i>true</i> if the data represent a narrow bandwidth derived from a full-band spectrum in the independent
 dimension <i>dim</i>. Because the data are one-dimensional, the value of <i>dim</i> is ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#isNarrow(int)">isNarrow</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd>
<dt><span class="strong">Returns:</span></dt><dd><i>true</i> if data are narrow-band</dd></dl>
</li>
</ul>
<a name="isNarrow()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isNarrow</h4>
<pre>public&nbsp;boolean&nbsp;isNarrow()</pre>
<div class="block">Returns <i>true</i> if the data represent a narrow bandwidth derived from a full-band spectrum.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>boolean <i>true</i> if data are narrow-band</dd></dl>
</li>
</ul>
<a name="setNarrow(boolean, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNarrow</h4>
<pre>public&nbsp;void&nbsp;setNarrow(boolean&nbsp;n,
             int&nbsp;dim)</pre>
<div class="block">Sets the narrow-band flag associated with the independent dimension <i>dim</i> (second argument) to the value of
 the first argument. Because the data are one-dimensional, the value of <i>dim</i> is ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#setNarrow(boolean, int)">setNarrow</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>n</code> - <i>true</i> if the data held are narrow-band</dd><dd><code>dim</code> - The index of the independent variable being set</dd></dl>
</li>
</ul>
<a name="setNarrow(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNarrow</h4>
<pre>public&nbsp;void&nbsp;setNarrow(boolean&nbsp;n)</pre>
<div class="block">Sets the narrow-band flag to the value of the argument.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>n</code> - <i>true</i> if the data held are narrow-band</dd></dl>
</li>
</ul>
<a name="getLowerFrequencyBound(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLowerFrequencyBound</h4>
<pre>public&nbsp;double&nbsp;getLowerFrequencyBound(int&nbsp;dim)</pre>
<div class="block">Returns the (non-negative) value of the lowest frequency in the frequency band held in the object, for the given
 direction <i>dim</i>. Because the data are one-dimensional, the value of <i>dim</i> is ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getLowerFrequencyBound(int)">getLowerFrequencyBound</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd>
<dt><span class="strong">Returns:</span></dt><dd>The lowest frequency represented in the given direction</dd></dl>
</li>
</ul>
<a name="getLowerFrequencyBound()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getLowerFrequencyBound</h4>
<pre>public&nbsp;double&nbsp;getLowerFrequencyBound()</pre>
<div class="block">Returns the (non-negative) value of the lowest frequency in the frequency band held in the object.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>double The lowest frequency represented in the given direction</dd></dl>
</li>
</ul>
<a name="getUpperFrequencyBound(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUpperFrequencyBound</h4>
<pre>public&nbsp;double&nbsp;getUpperFrequencyBound(int&nbsp;dim)</pre>
<div class="block">Returns the (non-negative) value of the highest frequency in the frequency band held in the object, for the given
 direction <i>dim</i>. Because the data are one-dimensional, the value of <i>dim</i> is ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getUpperFrequencyBound(int)">getUpperFrequencyBound</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd>
<dt><span class="strong">Returns:</span></dt><dd>The highest frequency represented in the given direction</dd></dl>
</li>
</ul>
<a name="getUpperFrequencyBound()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getUpperFrequencyBound</h4>
<pre>public&nbsp;double&nbsp;getUpperFrequencyBound()</pre>
<div class="block">Returns the (non-negative) value of the highest frequency in the frequency band held in the object.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>double The highest frequency</dd></dl>
</li>
</ul>
<a name="setUpperFrequencyBound(double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUpperFrequencyBound</h4>
<pre>public&nbsp;void&nbsp;setUpperFrequencyBound(double&nbsp;hf,
                          int&nbsp;dim)</pre>
<div class="block">Sets or resets the (non-negative) value of the highest frequency in the frequency band held in the object for the
 given direction <i>dim</i> to the given value <i>hf</i>. Because the data are one-dimensional, the value of
 <i>dim</i> is ignored.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#setUpperFrequencyBound(double, int)">setUpperFrequencyBound</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The index of the independent variable being queried</dd><dd><code>hf</code> - The new highest frequency represented in the given direction</dd></dl>
</li>
</ul>
<a name="setUpperFrequencyBound(double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUpperFrequencyBound</h4>
<pre>public&nbsp;void&nbsp;setUpperFrequencyBound(double&nbsp;hf)</pre>
<div class="block">Sets the (non-negative) value of the highest frequency in the frequency band held in the object to the given
 value. This should also set the <i>isNarrow</i> flag if the given value is not the highest value of the
 original-length spectrum.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>hf</code> - The new highest frequency</dd></dl>
</li>
</ul>
<a name="getFrequencyArray(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getFrequencyArray</h4>
<pre>public&nbsp;double[]&nbsp;getFrequencyArray(int&nbsp;dim)</pre>
<div class="block">Returns the frequency values of the independent data points for the given dimension, in the order of lowest
 frequency to highest, regardless of how the data are stored internally.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getFrequencyArray(int)">getFrequencyArray</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The dimension of the independent variable</dd>
<dt><span class="strong">Returns:</span></dt><dd>double[] Array of ordered frequency values</dd></dl>
</li>
</ul>
<a name="getOrderedSpectrumReal()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOrderedSpectrumReal</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getOrderedSpectrumReal()</pre>
<div class="block">Returns the real parts of the values of the spectrum (data points) in a multidimensional array, ordered so that
 in each dimension the values correspond to frequencies running from the lowest to the highest, regardless of the
 internal data model. These points then correspond to the values returned by <i>getFrequencyArray</i> for each
 dimension.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getOrderedSpectrumReal()">getOrderedSpectrumReal</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>Object Multidimensional arrray of ordered spectral values</dd></dl>
</li>
</ul>
<a name="getOrderedSpectrumImag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getOrderedSpectrumImag</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getOrderedSpectrumImag()</pre>
<div class="block">Returns the imaginary parts of the values of the spectrum (data points) in a multidimensional array, ordered so
 that in each dimension the values correspond to frequencies running from the lowest to the highest, regardless of
 the internal data model. These points then correspond to the values returned by <i>getFrequencyArray</i> for each
 dimension.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/Spectral.html#getOrderedSpectrumImag()">getOrderedSpectrumImag</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/Spectral.html" title="interface in triana.types">Spectral</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>Object Multidimensional arrray of ordered spectral values</dd></dl>
</li>
</ul>
<a name="getNyquist()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNyquist</h4>
<pre>public&nbsp;double&nbsp;getNyquist()</pre>
<div class="block">Returns the Nyquist frequency, defined to be the highest frequency that this data set could contain if it were
 not narrow-banded. For full-bandwidth sets, this is the same value as is returned by
 <i>getUpperFrequencyBound()</i>, but for narrow-band data sets it may be higher. </p><p> The general formula is
 that if the original number of data points (given by <i> nFull = getOriginalN()</i>) is even, then the Nyquist
 frequency is <i>nFull * resolution / 2</i>. If the original number of data points is odd, then the Nyquist
 frequency is <i>(nFull -1 ) * resolution / 2</i>.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>double The Nyquist frequency</dd></dl>
</li>
</ul>
<a name="getSamplingRate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSamplingRate</h4>
<pre>public&nbsp;double&nbsp;getSamplingRate()</pre>
<div class="block">Returns the sampling frequency that a time-series would have had if it had led to the present spectral data set.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>double The sampling frequency</dd></dl>
</li>
</ul>
<a name="samplingFrequency()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>samplingFrequency</h4>
<pre>public&nbsp;double&nbsp;samplingFrequency()</pre>
<div class="block">Obsolete method for obtaining sampling frequency. Will be withdrawn.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the sampling frequency</dd></dl>
</li>
</ul>
<a name="points()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>points</h4>
<pre>public&nbsp;int&nbsp;points()</pre>
<div class="block">Obsolete method for obtaining the number of data points. Will be withdrawn.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the number of points in this Spectrum</dd></dl>
</li>
</ul>
<a name="frequencyResolution()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>frequencyResolution</h4>
<pre>public&nbsp;double&nbsp;frequencyResolution()</pre>
<div class="block">Obsolete method for obtaining frequency resolution. Will be withdrawn.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>the frequency resolution</dd></dl>
</li>
</ul>
<a name="getIndependentScaleReal(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIndependentScaleReal</h4>
<pre>public&nbsp;double[]&nbsp;getIndependentScaleReal(int&nbsp;dim)</pre>
<div class="block">Returns the independent data scaled the way they should be graphed.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#getIndependentScaleReal(int)">getIndependentScaleReal</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The independent dimension under consideration</dd>
<dt><span class="strong">Returns:</span></dt><dd>The scaled independent data values</dd></dl>
</li>
</ul>
<a name="getIndependentScaleImag(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getIndependentScaleImag</h4>
<pre>public&nbsp;double[]&nbsp;getIndependentScaleImag(int&nbsp;dim)</pre>
<div class="block">Returns null because the data is real.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#getIndependentScaleImag(int)">getIndependentScaleImag</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dim</code> - The independent dimension under consideration</dd>
<dt><span class="strong">Returns:</span></dt><dd>The scaled independent data values</dd></dl>
</li>
</ul>
<a name="getGraphArrayReal(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGraphArrayReal</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getGraphArrayReal(int&nbsp;dv)</pre>
<div class="block">Returns the real part of the dependent variable ordered so that the frequency values all run monotonically
 upwards.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#getGraphArrayReal(int)">getGraphArrayReal</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dv</code> - The dependent variable dimension</dd>
<dt><span class="strong">Returns:</span></dt><dd>Object An array containing the rearranged data values</dd></dl>
</li>
</ul>
<a name="getGraphArrayImag(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGraphArrayImag</h4>
<pre>public&nbsp;java.lang.Object&nbsp;getGraphArrayImag(int&nbsp;dv)</pre>
<div class="block">Returns the imaginary part of the dependent variable ordered so that the frequency values all run monotonically
 upwards.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#getGraphArrayImag(int)">getGraphArrayImag</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dv</code> - The dependent variable dimension</dd>
<dt><span class="strong">Returns:</span></dt><dd>Object An array containing the rearranged data values</dd></dl>
</li>
</ul>
<a name="extendWithZeros(int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>extendWithZeros</h4>
<pre>public&nbsp;void&nbsp;extendWithZeros(int&nbsp;newLength,
                   boolean&nbsp;front)</pre>
<div class="block">Extends the data set to a longer set by padding with zeros, keeping the frequency resolution unchanged. If the
 new length is shorter than the old (as given by method <i>getOriginalN</i>, then nothing is done. This method
 does <i>not</i> use the method of the same name in VectorType. Instead it takes advantage of the narrow-band
 feature of the Triana spectral data model to add zeros "virtually", without increasing the storage required. The
 way this is done depends on the value of the given parameter <i>front</i>. </p><p> If <i>front</i> is
 <i>true</i>, then nothing is done and a warning message is printed to the debug stream, because it is not
 possible in the Triana spectral model to extend a spectrum "below" zero-frequency. Negative frequencies are
 already included in the spectrum either explictly or implicitly, so there is no room for more points at the
 "front" of the data set. Even if the data set is narrow-band and does not include zero frequency, the data down
 to zero frequency are already set to zero implicitly, so that there is no way to add more of them. </p><p> If the
 boolean argument <i>front</i> is <i>false</i>, then the method extends the spectrum to higher frequencies, but
 the extra zeros are added "virtually", <i>i.e.</i> by extending the length <i>nFull</i> of the original data set
 and not adding the zeros explicitly. If the original data set was broad-band, it is marked as narrow-band after
 extension. </p><p> The details of how this works are best understood by thinking of the original (un-extended)
 data set as having been obtained from the final (extended one) by low-pass filtering. It is a consequence of the
 Triana spectral data model that applying a low-pass filter to a data set of any length <i>nFull</i> results in a
 data set whose new value of <i>nFull</i> is odd. If the data set before extension has an odd number of elements,
 then the extension requires only the actions described above. </p><p> On the other hand, if the data set before
 extension has an even value of <i>nFull</i>, then it must be converted to one with an odd number before it can be
 extended. This is done in this method by identifying all the elements of the old set with those of the new one
 with the same frequency except for the highest frequency. In the new (odd-length) set there are two elements for
 the highest frequency, one at positive frequency and one at negative. In the old (even-length) set there is only
 one, at the negative frequency. The elements of the new one are determined as follows. If the spectrum is real,
 then it is assumed to be a power spectrum, and the negative-frequency element is set equal to the old
 negative-frequency element divided by 2, and the positive-frequency element is set equal to this. If the spectrum
 is complex, then it is assumed to represent a Fourier transform, and the negative-frequency element is set equal
 to the old negative-frequency element divided by sqrt(2), while the positive-frequency element is set equal to
 the complex- conjugate of this value. This choice is rather arbitrary, but it ensures that, under the
 assumptions, the <i>total power</i> is unchanged. Of course, if the original data is narrow-band and has already
 lost its highest frequencies, then the new element is just set to zero, and this is done "virtually", by
 adjusting various parameters. If the data set is one-sided, then only the positive-frequency element is added.
 When an element is added, then the independent variable Triplet is extended by one as well.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/VectorType.html#extendWithZeros(int, boolean)">extendWithZeros</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>newLength</code> - The new length of the data set</dd><dd><code>front</code> - True if padding is at the front, false for padding at the back</dd></dl>
</li>
</ul>
<a name="interpolateZeros(int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interpolateZeros</h4>
<pre>public&nbsp;void&nbsp;interpolateZeros(int&nbsp;factor,
                    boolean&nbsp;before)</pre>
<div class="block">Inserts zeros in between existing elements of the data set. The integer argument <i>factor</i> gives the number
 of zeros per existing data point that must be inserted. The boolean argument <i>before</i> regulates whether the
 zeros should be inserted before each element (if <i>true</i>) or after (<i>false</i>). The new values of the
 independent variable are interpolated between those of the old ones. </p><p> If the argument <i>factor</i> is
 zero or negative, nothing is done. </p><p> In Spectrum, the interpolation is done in such a way that the
 frequency resolution is increased and the pre-existing data points remain at the same value of the frequency.
 This means that it is illegal to add zeroes before the first element, which corresponds to zero frequency. So if
 <i>before</i> is <i>true</i> then the method returns without doing anything, and prints a warning. </p><p> If the
 value of <i>before</i> is <i>false</i>, then the interpolation is done in such a way that the frequency
 resolution is divided by (<i>factor</i> + 1) and the original number of points is changed by (<i>factor</i> + 1).
 This ensures that the original data points remain at the same values of the frequency. The requisite number of
 zeros is added after each data point. If the spectrum is two-sided, then the way interpolation as done in
 <i>VectorType</i> is correct here too, and only the parameters are changed, as just described. If the spectrum is
 one-sided, then ordinary interpolation adds too many at the end, and this method removes the extra ones. </p><p>
 Derived types should override this if necessary to provide for the correct handling of parameters and other
 special features.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/VectorType.html#interpolateZeros(int, boolean)">interpolateZeros</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>factor</code> - The number of zeros per data point to be inserted</dd><dd><code>before</code> - <i>True</i> if the zeros go before each point, <i>false</i> if after</dd></dl>
</li>
</ul>
<a name="copyMe()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyMe</h4>
<pre>public&nbsp;<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;copyMe()</pre>
<div class="block">This is one of the most important methods of Triana data. types. It returns a copy of the type invoking it. This
 <b>must</b> be overridden for every derived data type derived. If not, the data cannot be copied to be given to
 other units. Copying must be done by value, not by reference. </p><p> To override, the programmer should not
 invoke the <i>super.copyMe</i> method. Instead, create an object of the current type and call methods
 <i>copyData</i> and <i>copyParameters</i>. If these have been written correctly, then they will do the copying.
 The code should createTool, for type YourType: <PRE> YourType y = null; try { y =
 (YourType)getClass().newInstance(); y.copyData( this ); y.copyParameters( this ); y.setLegend( this.getLegend()
 ); } catch (IllegalAccessException ee) { System.out.println("Illegal Access: " + ee.getMessage()); } catch
 (InstantiationException ee) { System.out.println("Couldn't be instantiated: " + ee.getMessage()); } return y;
 </PRE> </p><p> The copied object's data should be identical to the original. The method here modifies only one
 item: a String indicating that the object was created as a copy is added to the <i>description</i> StringVector.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/VectorType.html#copyMe()">copyMe</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></code></dd>
<dt><span class="strong">Returns:</span></dt><dd>TrianaType Copy by value of the current Object except for an updated <i>description</i></dd></dl>
</li>
</ul>
<a name="copyParameters(triana.types.TrianaType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyParameters</h4>
<pre>protected&nbsp;void&nbsp;copyParameters(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;source)</pre>
<div class="block">Copies modifiable parameters from the argument object to the current object. The copying is by value, not by
 reference. Parameters are defined as data not held in <i>dataContainer</i>. They are modifiable if they have
 <i>set...</i> methods. Parameters that cannot be modified, but which are set by constructors, should be placed
 correctly into the copied object when it is constructed. </p><p> In Spectrum, the new parameters are
 <i>resolution</i>, <i>highestFrequency</i>, <i>twoSided</i>, <i>narrow</i>, <i>nFull</i>. The obsolete parameters
 <i>samplingFrequency</i> and <i>frequencyResolution</i> are generated automatically when the other parameters are
 copied and set. </p><p> This must be overridden by any subclass that defines new parameters. The overriding
 method should invoke its <i>super</i> method. It should use the <i>set...</i> and <i>get...</i> methods for the
 parameters in question. This method is protected so that it cannot be called except by objects that inherit from
 this one. It is called by <i>copyMe()</i>.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#copyParameters(triana.types.TrianaType)">copyParameters</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>source</code> - Data object that contains the data to be copied.</dd></dl>
</li>
</ul>
<a name="outputToStream(java.io.PrintWriter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>outputToStream</h4>
<pre>public&nbsp;void&nbsp;outputToStream(java.io.PrintWriter&nbsp;dos)
                    throws java.io.IOException</pre>
<div class="block">Used when Triana types want to be able to send ASCII data to other programs using strings.  This is used to
 implement socket and to run other executables, written in C or other languages. With ASCII you don't have to
 worry about ENDIAN'ness as the conversions are all done via text. This is obviously slower than binary
 communication since you have to format the input and output within the other program. </p><p> This method must be
 overridden in every subclass that defines new data or parameters. The overriding method should first call<<PRE>
 super.outputToStream(dos) </PRE>to get output from superior classes, and then new parameters defined for the
 current subclass must be output. Moreover, subclasses that first dimension their data arrays must explicitly
 transfer these data arrays.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/AsciiComm.html#outputToStream(java.io.PrintWriter)">outputToStream</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/AsciiComm.html" title="interface in triana.types">AsciiComm</a></code></dd>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#outputToStream(java.io.PrintWriter)">outputToStream</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dos</code> - The data output stream</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="inputFromStream(java.io.BufferedReader)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inputFromStream</h4>
<pre>public&nbsp;void&nbsp;inputFromStream(java.io.BufferedReader&nbsp;dis)
                     throws java.io.IOException</pre>
<div class="block">Used when Triana types want to be able to receive ASCII data from the output of other programs.  This is used to
 implement socket and to run other executables, written in C or other languages. With ASCII you don't have to
 worry about ENDIAN'ness as the conversions are all done via text. This is obviously slower than binary
 communication since you have to format the input and output within the other program. </p><p> This method must be
 overridden in every subclass that defines new data or parameters. The overriding method should first call<PRE>
 super.inputFromStream(dis) </PRE>to get input from superior classes, and then new parameters defined for the
 current subclass must be input. Moreover, subclasses that first dimension their data arrays must explicitly
 transfer these data arrays.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../triana/types/AsciiComm.html#inputFromStream(java.io.BufferedReader)">inputFromStream</a></code>&nbsp;in interface&nbsp;<code><a href="../../triana/types/AsciiComm.html" title="interface in triana.types">AsciiComm</a></code></dd>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/GraphType.html#inputFromStream(java.io.BufferedReader)">inputFromStream</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/GraphType.html" title="class in triana.types">GraphType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>dis</code> - The data input stream</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="isCompatible(triana.types.TrianaType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCompatible</h4>
<pre>public&nbsp;boolean&nbsp;isCompatible(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;obj)</pre>
<div class="block">Tests the argument object to determine if it makes sense to perform arithmetic operations between it and the
 current object. </p><p> In Spectrum, this method first tests for compatibility with superior classes, and then
 (if the input object is a Spectrum) tests that the input has the same frequency resolution, upper frequency
 bound, two-sidedness, and narrow-bandedness as the current object. </p><p> Classes derived from this should
 over-ride this method with further tests as appropriate. The over-riding method should normally have the first
 lines <PRE> boolean test = super.isCompatible( obj ); </PRE>followed by other tests. If other types not
 subclassed from GraphType or Const should be allowed to be compatible then other tests must be implemented.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/VectorType.html#isCompatible(triana.types.TrianaType)">isCompatible</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>obj</code> - The data object to be compared with the current one</dd>
<dt><span class="strong">Returns:</span></dt><dd><I>True</I> if the object can be combined with the current one</dd></dl>
</li>
</ul>
<a name="equals(triana.types.TrianaType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre>public&nbsp;boolean&nbsp;equals(<a href="../../triana/types/TrianaType.html" title="class in triana.types">TrianaType</a>&nbsp;obj)</pre>
<div class="block">Determines whether the argument TrianaType is equal to the current Spectrum. They are equal if the argument is a
 Spectrum with the same size, parameters, and data. </p><p> This method must be over-ridden in derived types. In a
 derived type called xxx the method should begin<PRE> if ( !( obj instanceof xxx ) ) return false; if (
 !isCompatible( obj ) ) return false; </PRE>followed by tests that are specific to type xxx (testing its own
 parameters) and then as a last line<PRE> return super.equals( obj ); </PRE>This line invokes the other equals
 methods up the chain to GraphType. Each superior object tests its own parameters.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>obj</code> - The object being tested</dd>
<dt><span class="strong">Returns:</span></dt><dd><i>true</i> if they are equal or <i>false</i> otherwise</dd></dl>
</li>
</ul>
<a name="updateObsoletePointers()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateObsoletePointers</h4>
<pre>protected&nbsp;void&nbsp;updateObsoletePointers()</pre>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../triana/types/VectorType.html#updateObsoletePointers()">updateObsoletePointers</a></code>&nbsp;in class&nbsp;<code><a href="../../triana/types/VectorType.html" title="class in triana.types">VectorType</a></code></dd>
</dl>
</li>
</ul>
<a name="reduceNyquist(triana.types.Spectrum, boolean)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>reduceNyquist</h4>
<pre>public static&nbsp;<a href="../../triana/types/Spectrum.html" title="class in triana.types">Spectrum</a>&nbsp;reduceNyquist(<a href="../../triana/types/Spectrum.html" title="class in triana.types">Spectrum</a>&nbsp;inputNarrow,
                     boolean&nbsp;allocMem)</pre>
<div class="block">Class method that takes an input narrow-band Spectrum and reduces <i>nFull</i> to be compatible with the upper
 frequency bound, so that the set is no longer narrow-band at the top. This is useful in doing resampling of
 time-series data. The Nyquist frequency is the highest frequency allowed by the sampling rate. If the input is
 not narrow-band, then the method returns null.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>inputNarrow</code> - The input narrow-band spectrum</dd><dd><code>allocMem</code> - <i>True</i> if the output is a modified copy of input</dd>
<dt><span class="strong">Returns:</span></dt><dd>The reduced-sampling-rate spectrum</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../triana/types/Spectral.html" title="interface in triana.types"><span class="strong">Prev Class</span></a></li>
<li><a href="../../triana/types/Spectrum2D.html" title="class in triana.types"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?triana/types/Spectrum.html" target="_top">Frames</a></li>
<li><a href="Spectrum.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
