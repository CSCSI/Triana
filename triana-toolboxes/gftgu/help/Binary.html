<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    <meta name="Generator" content="Microsoft Word 97">
    <meta name="Template"
          content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
    <meta name="GENERATOR"
          content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
    <meta name="Author" content="Bernard F Schutz">
    <meta name="Description"
          content="Help file for Triana unit Binary, part of the toolbox for the book Gravity from the Ground Up.This unit simulates the orbits of two bodies under the effect of their mutual gravitational attraction.">
    <meta name="KeyWords"
          content="Gravity from the ground up, Triana, help file">
    <title>Binary</title>
</head>
<body text="#000000" bgcolor="#fdf5e6" link="#808080" vlink="#808080"
      alink="#ff0000" background="BH-posneg.negative.watermark.png">
<span style="font-weight: bold;"><a href="license.html"><img
        src="HelpfileBanner.png" title="Click to view license information."
        alt="" style="border: 0px solid ; width: 375px; height: 362px;"
        align="right"></a></span><br>
<table cellpadding="2" cellspacing="2" border="3"
       style="text-align: left; width: 50%; margin-left: auto; margin-right: auto;">
    <tbody>
    <tr>
        <td
                style="vertical-align: top; background-color: rgb(204, 204, 204);">
            <h3
                    style="color: rgb(102, 255, 153); font-family: monospace; font-weight: bold; text-align: center;">
                <big><big><big><big><span
                        style="color: rgb(255, 0, 0);">Binary<br>
      </span></big></big></big></big></h3>

            <div style="text-align: center;"><big><font size="+2"><big><span
                    style="color: rgb(255, 0, 0);"><small><span style="font-weight: bold;"><small><span
                    style="color: rgb(0, 0, 0);">version 1.0<br>
      </span></small></span></small></span></big></font><big><big><span
                    lang="EN-GB"
                    style="font-size: 12pt; font-family: &quot;Times New Roman&quot;; font-weight: bold;">&copy;
                2003 Bernard Schutz</span></big></big></big><br>
            </div>
            <h3
                    style="font-family: helvetica,arial,sans-serif; text-align: center;">
                <large><b><span
                        style="color: rgb(0, 0, 0);">Simulate the motion of two stars in a
binary orbit around one another. The user can choose initial stellar
masses, positions and velocities to represent any kind of orbit. The
program can output graphs of the orbits, of the velocity evolution, of
the positions and speeds as functions of time, and of the kinetic and
potential energies as functions of time.<br>
      </span></b></large>
            </h3>
        </td>
    </tr>
    </tbody>
</table>
<p><br>
</p>

<h2><a name="contents"></a>Contents</h2>
<ul>
    <li><a href="#description">Description of <tt><font size="+1">Binary</font></tt></a></li>
    <li><a href="#using">Using <tt><font size="+1">Binary</font></tt></a></li>
    <li><a href="#playing">Suggestions for playing with <tt><font
            size="+1">Binary</font></tt></a></li>
    <li><a href="#understanding">Understanding <tt><font size="+1">Binary</font></tt></a></li>
    <li><a href="#suggestions">Suggested modifications of <tt><font
            size="+1">Binary</font></tt></a></li>
    <li><a href="#listing">Listing of the Java code for <tt><font
            size="+1">Binary</font></tt></a></li>
</ul>
<hr width="15%" size="4">
<h2><a name="description"></a>Description of <tt><font size="+3">Binary</font></tt></h2>
The unit called <tt><font size="+1">Binary</font></tt> implements the
Java
program for computing orbits of binary stars. Using the mathematics
developed
in Investigations 13.1 and 13.2, the program calculates the
acceleration
produced in each of the two bodies by the gravitational force of the
other.
The user can specify everything necessary about the binary stars in the
parameter window: their masses, initial positions, and initial
velocities.
The program can therefore be used to simulate circular or elliptical
orbits,
systems with equal or very different masses, systems consisting of
stars
or planets. The program is a generalization of the program <tt><font
        size="+1"><a href="Orbit.html">Orbit</a></font></tt>,
and therefore it allows the user to specify a time-step, a maximum
number
of steps, and accuracy parameters for reducing the time-step or
iterating
the predictor-corrector method.
<p></p>
<hr width="15%" size="4">
<h2><a name="using"></a>Using <tt><font size="+3">Binary</font></tt></h2>
Simply drag the <tt><font size="+1">Binary</font></tt> icon from the
toolbox
into the working area, drag the <tt><font size="+1">SGTGrapher</font></tt>
unit into the area, and connect the two if Triana has not already done
so. You will notice that <tt><font size="+1">Binary</font></tt> has
two output
nodes. These are for the data for each of the two bodies. You should
add
an extra input node to the grapher icon (hover your mouse near the
input
node of this icon, and click on the little "+" that appears) and
connect
the second output of <tt><font size="+1">Binary</font></tt> to it. If
you
press the <tt><font size="+1">Start</font></tt> button then the
program will
execute with its default settings, producing a simulation of the
orbital
motion of two equal-mass stars in highly elliptical orbits around one
another. To get a plot that shows the orbits correctly, go to the
"Plot" menu of the <tt><font size="+1">SGTGrapher</font></tt> display,
and select "force equal ranges
on both axes", then press "Reset Zoom".&nbsp; This ensures that the <span
        style="font-style: italic;">x</span>- and <span
        style="font-style: italic;">y</span>- axes are scaled in the same way.
Optionally, if you find the axis labels difficult to read, you can
select "take out common factors of 10 from data" for a less cluttered
display. You will have to re-run the computation to get the display to
change.<br>

<p><img src="imageDSJ.JPG" height="337" width="615" align="left">You
    can change
    11 parameters using the parameter window. The first one is the initial
    position of the first body, called "body A". Rather than enter the x-
    and
    y-coordinates of its position in separate lines, as in <tt><font
            size="+1">Orbit</font></tt>,
    here you enter them (in meters) in the same field, simply separated by
    spaces. (Do <i>not</i> put a comma between them or brackets around
    them.
    This will confuse the computer! But you <i>can</i> use more than one
    space,
    and you can put spaces before and after the numbers as well. These
    extra
    spaces will be ignored.) In the second line you enter the starting
    position
    of "body B". In the next two lines you enter their initial velocities,
    again using numbers with spaces between to give the two velocity
    components
    (in meters per second). Lines 5 and 6 allow you to enter the masses of
    the bodies (in kg), and the remaining lines are similar to those in <tt><font
            size="+1">Orbit</font></tt>.
    You should adjust the time-step and accuracy parameters if the
    calculation
    seems to be taking too long; allowing a lower degree of accuracy may
    still
    give acceptable results and could speed up the computation. To check
    whether
    the accuracy is acceptable, do an identical run with higher accuracy;
    if
    the result is not perceptibly different then you can feel safe at the
    lower
    accuracy settings.
</p>

<p><img src="imageE10.JPG" border="0" height="156" width="163"
        align="left">The
    final choice-box opens up as shown here. Normally you will want to use
    the first option, to draw the orbits. But if you are interested in the
    velocities, or the periods of the orbits, or the conservation of
    energy,
    you can display the other quantities. There are some suggestions in the
    next section about using these other options. The choices are similar
    to
    those for <tt><font size="+1">Orbit</font></tt>, so you should see the
    <a href="Orbit.html">help
        file</a> for that program for further explanation. The final option,
    plotting
    the different energies against time, requires three outputs, so when
    you
    select this Triana automatically adds another output node to the <tt><font
            size="+1">Binary</font></tt>
    unit. You need to add an extra input node to the <tt><font size="+1">SGTGrapher</font></tt>
    unit and then connect it to the third output node.
    <br>
    &nbsp;
</p>

<p></p>
<hr width="15%" size="4">
<h2><a name="playing"></a>Suggestions for playing with <tt><font
        size="+3">Binary</font></tt></h2>
As we add more and more realism to our orbit programs, they become
capable
of representing a richer variety of situations. The orbits we have
chosen
for the initial data are not particularly special. You can learn a lot
about Newtonian gravity by running the program over again with
different
values of some of the parameters. Here are some suggestions of what you
can do without any programming.
<ol>
    <li><b>Unequal masses</b><i>.</i> Choose the masses unequal, and do
        several
        runs with masses for, say <tt><font size="+1">B</font></tt>, that get
        smaller
        and smaller. To get output that is nice to look at you need to be
        careful
        with the choice of initial velocities. The initial data provided in the
        program are such that the total momentum of the system is zero. You
        should
        make sure this is still true when you change the masses, and this will
        usually involve reducing the initial velocity of the heavier body. The
        total momentum is found by multiplying the mass of each body by its
        initial
        velocity and adding the two. If you do not choose data for which the
        total
        momentum is zero, then the system as a whole will move away, and in the
        plot of positions produced by <tt><font size="+1">SGTGrapher</font></tt>,
        you will see the bodies
        looping
        around one another as they move off. This might be fun to look at but
        it
        makes understanding the orbits harder. We will come back to this in the
        fourth suggestion below.<br>
    </li>
    <p>First do circular orbits to try to reproduce the orbits shown in
        Figure 13.3 (right-hand panel) of the book. Then vary the speeds again
        to get elliptical orbits. Notice that the heavier body <tt><font
                size="+1">A</font></tt>
        moves less than <tt><font size="+1">B</font></tt>, and that when the
        mass
        ratio is extremely small the orbits reproduce the output of <tt><font
                size="+1">Orbit</font></tt>
        for similar starting conditions. Take initial conditions appropriate
        for
        the binary system consisting of the Sun and Jupiter, and verify that
        the
        Sun's small orbit has a radius slightly larger than the Sun's own size.
        Change to initial conditions for, say, the Sun and Saturn, and verify
        that
        the effect on the Sun is significantly smaller. Do this again for the
        Sun
        and the Earth. In reality, of course, the Sun moves because of all the
        planets together, but Jupiter is the main agent. When we get to the
        program <tt><font size="+1"><a href="Multiple.html">Multiple</a></font></tt>,
        you can try to simulate the whole Solar System if you want! </p>
    <li><b>Bound and unbound orbits</b>. Change the initial velocities so
        that
        the orbits become unbound, i.e. the bodies fly apart without returning.
        When this happens, output the energies for the same initial conditions,
        and verify that the total energy is positive rather than negative.
    </li>
    <li><b>Displace the origin</b><i>.</i> Test our assertion above
        that
        the location
        of the coordinate origin is irrelevant. Add a large constant value to
        both
        of the initial x-values and another to both of the initial y-values in
        the parameter window. The orbits should look exactly the same, only
        displaced
        to a different location.
    </li>
    <li><b>Test the principle of relativity</b><i>.</i> Try the same
        thing
        with
        the velocity: add a large constant to both the initial x-velocities and
        a different one to both initial y-velocities, so that now the total
        momentum
        of the system is not zero. The result will be an orbit that moves
        across
        your computer screen in the <tt><font size="+1">SGTGrapher </font></tt>display
        window, so it won't look
        closed: it should look helical. But we know from Galileo's principle of
        relativity that this is just an effect of the observer, and that if we
        travelled with the speed given by the values we added to the initial
        data,
        then the orbit will look closed. To test this at least partially,
        choose
        to output "velocity space". Here you should see the same velocity curve
        as originally, only displaced by the large amounts you added. You are
        testing
        the principle of relativity with this experiment, and that of course
        will
        be one of the foundation-stones of the second half of the book.
    </li>
</ol>
<p><br>
</p>
<hr width="15%" size="4">
<h2><a name="understanding"></a>Understanding <tt><font size="+3">Binary</font></tt></h2>
There is not a big difference between <tt><font size="+1">Orbit</font></tt>
and <tt><font size="+1">Binary</font></tt>. You should read the
description
of how <tt><font size="+1"><a href="Orbit.html#understanding">Orbit</a></font></tt>
works before trying to understand <tt><font size="+1">Binary</font></tt>.
<p>One difference is that many variables occur twice, once with the
    last
    letter <tt><font size="+1">A</font></tt> and once with <tt><font
            size="+1">B</font></tt>,
    to refer to the two bodies. Another is that the acceleration of body <tt><font
            size="+1">A</font></tt>
    depends on the mass and relative location of body <tt><font size="+1">B</font></tt>,
    and vice-versa. Therefore, the position variables used in the
    acceleration
    computation are <tt><font size="+1">xAB</font></tt> and <tt><font
            size="+1">yAB</font></tt>,
    the components of the displacement vector pointing from body <tt><font
            size="+1">B</font></tt>
    to body <font size="+1"><tt>A</tt>. </font>The magnitude of this
    displacement
    is called <tt><font size="+1">rAB</font></tt> and its cube is <tt><font
            size="+1">rAB3</font></tt>.
    The variable <tt><font size="+1">kGravityA</font></tt> holds the value
    of
    GM<sub>A</sub>, which is required to compute the acceleration of <tt><font
            size="+1">B</font></tt>;
    and similarly for <tt><font size="+1">kGravityB</font></tt>. Thus, the
    acceleration
    components of the two bodies are computed with the code like the
    following:
    <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        axA = -kGravityB*xAB/rAB3;</font></tt>
    <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ayA = -kGravityB*yAB/rAB3;</font></tt>
    <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        axB = kGravityA*xAB/rAB3;</font></tt>
    <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ayB = kGravityA*yAB/rAB3;</font></tt>
    <br>
    Notice the difference of sign, which is required because the variable
    <tt><font size="+1">xAB</font></tt>
    represents the x-displacement of <tt><font size="+1">A</font></tt>
    from <tt><font size="+1">B</font></tt>,
    and is used in both formulas. The acceleration of <tt><font size="+1">A</font></tt>
    is toward <tt><font size="+1">B</font></tt>, so is opposite in sign to
    this
    variable; but the acceleration of <tt><font size="+1">B</font></tt> is
    toward
    <tt><font size="+1">A</font></tt>
    and has the same sign as this variable.
</p>

<p>Similarly, the computation of the angles that are used to see if the
    system has completed one full orbit uses the angle of the displacement
    of <tt><font size="+1">A</font></tt> from <tt><font size="+1">B</font></tt>,
    not the angles of either body with respect to the origin of
    coordinates.
    The coordinate origin is irrelevant here. In the program <tt><font
            size="+1">Orbit</font></tt>
    it was physically important because the gravitating body (the "Sun")
    sat
    there. But in this problem the coordinates could be chosen so that the
    origin is anywhere; the only physically important displacement is that
    from one body to the other. (See suggestion number 3 in the previous
    section.)
</p>

<p>The time-step check and the predictor-corrector both work just on
    the
    values of the variables for body <tt><font size="+1">A</font></tt>.
    That
    is because these tests are really tests of how big the fractional
    changes
    in various quantities are, and it is clear from the above four lines of
    code that both bodies will experience the same fractional changes in
    acceleration
    when the position is changed. Therefore only one needs to be tested.
</p>

<p>As with Orbit, there are several choices of output and so the output
    section is rather involved. This need not be of interest to you if you
    are just trying to understand the physics of orbits.
    <br>
    &nbsp;
</p>

<p></p>
<hr width="15%" size="4">
<h2><a name="suggestions"></a>Suggested modifications of <tt><font
        size="+3">Binary</font></tt></h2>
Since Binary is derived from Orbit, the suggestions we made for Orbit
apply
equally here. If you have done any of them, then you can try to
implement
them here too. One obvious further modification, of increasing the
number
of bodies to three or more, is something we will do in the later
programs
<tt><font size="+1"><a href="MercPert.html">MercPert</a></font></tt>
and
<tt><font size="+1"><a href="Multiple.html">Multiple</a></font></tt>.
<p>If you want to change the program you will have to re-compile it, as
    explained by the help file <a href="UsingTriana.html">Using Triana for
        <i>Gravity
            from the ground up</i></a>.
</p>

<p></p>
<hr width="15%" size="4">
<h2><a name="listing"></a>Listing of the Java code for <tt><font
        size="+3">Binary</font></tt></h2>

<h3>
    Preliminary definitions of parameters and constants</h3>
<tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initPosA is the String used by the
    program to allow users</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to input the initial position of
    body A in the parameter</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; window. The String is processed
    to obtain the initial x-</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and y-positions, which are stored
    in xInitA and yInitA.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; There are analogous variables for
    body B. All positions</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; are given in meters.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; */</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; private String initPosA;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; private double xInitA;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; private double yInitA;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; private String initPosB;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; private double xInitB;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; private double yInitB;</tt>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; initVelA is the String used by the program to
        allow users</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; to input the initial velocity of body A in the
        parameter</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; window. The String is processed to obtain the
        initial x-</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; and y-velocity components, which are stored
        in vInitA</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; and uInitA. There are analogous variables for
        body B. All</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; velocities are given in m/s.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private String initVelA;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double vInitA;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double uInitA;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private String initVelB;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double vInitB;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double uInitB;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MA is the mass (in kg) of body A.
        MB is that of body B. Both</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; are set by the user in the parameter
        window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double MA;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double MB;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt is the time-step in seconds.
        It is set by the user in the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double dt;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxSteps is the maximum number of
        steps in the calculation.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This is used to ensure that the
        calculation will stop even</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if initial values are chosen so
        that the projectile goes far</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; away. It is set by the user in the
        parameter window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private int maxSteps;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eps1 sets the accuracy of the
        time-step.
        If computed quantities</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; change by a larger fraction than
        this in a time-step, the time-step</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; will be cut in half, repeatedly
        if necessary. It is set by the user</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in the parameter window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double eps1;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eps2 sets the accuracy of the
        predictor-corrector
        step. Averaging</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; over the most recent time-step is
        iterated until it changes by</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; less than this relative amount.
        It is set by the user in the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double eps2;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputType regulates the data that
        is to be output from the program.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The computation produces many kinds
        of data: positions, velocities,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; energies. In order to make them
        accessible, the user can select a</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value for this String, and the unit
        will output the required data.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; First-time programmers can safely
        ignore these output issues, which</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add some length to the program,
        although in a straightforward way.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Here are the choices and the data
        that they produce:</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "orbits" is the default choice
        and produces two curves containing</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the orbits of the two
        bodies drawn in the X-Y plane. The unit</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputs this data from
        two output nodes, which should both be</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connected to the same
        graphing unit. (To connect two inputs to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the grapher the user
        must use the grapher unit's node window</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to set the number of
        input nodes to two.)</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "velocity space" produces two
        curves in what physicists call</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; velocity space, a graph
        whose axes are the x- and y-components of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the velocity. Since
        a body on a closed orbit also comes back to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the same velocity after
        one orbit, the graphs of these curves will</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be closed for such
        orbits.
        The unit outputs this data from two</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output nodes, which
        should be connected to the same graphing unit.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "position vs. time, body A"
        produces
        two curves for body A, one giving</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the value of the
        X-coordinate
        (vertical axis of the graph) against</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the time along the orbit
        (horizontal axis) and the second giving the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y-coordinate against
        time. The unit outputs this data from two</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output nodes, which
        should be connected to the same graphing unit.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "position vs. time, body B"
        produces
        two curves for body B, one giving</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the value of the
        X-coordinate
        (vertical axis of the graph) against</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the time along the orbit
        (horizontal axis) and the second giving the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y-coordinate against
        time. The unit outputs this data from two</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output nodes, which
        should be connected to the same graphing unit.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "velocity vs. time, body A" This
        does the same for body A as the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position choice except
        that it produces the x- and y-components of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the velocity (V and
        U) as functions of time instead of the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coordinate positions.
        Again the unit outputs this data from two</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output nodes, which
        should be connected to the same graphing unit.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "velocity vs. time, body B" This
        does the same for body B as the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position choice except
        that it produces the x- and y-components of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the velocity (V and
        U) as functions of time instead of the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coordinate positions.
        Again the unit outputs this data from two</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output nodes, which
        should be connected to the same graphing unit.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "energy vs time" This produces
        three curves: the potential energy,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the kinetic energy,
        and the total energy, all as functions of time.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The unit changes itself
        to three output nodes and the data are output</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in the order given in
        the previous sentence. To see all three at</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; once, modify the number
        of input nodes of the grapher to three and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connect them all.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private String outputType;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; G is Newton's gravitational
        constant.
        It is used internally and not</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set by the user.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double G = 6.6726e-11;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This variable is for internal use
        and is not set by the user.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private TaskInterface task;</tt>
    <br>
    &nbsp;
    <br>
    &nbsp;
</p>

<h3>Program code</h3>
<tt>&nbsp;&nbsp;&nbsp; public void process() throws Exception {</tt>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Define and
    initialize the variables we will need for the calculation:</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - t is the
    time since the beginning of the orbit.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - dt1 will
    be used as the "working" value of the time-step, which can</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    be changed during the calculation. Using dt1 for the time-step allows</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    us to keep dt as the original value, as specified by the user. Thus,</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    dt1 is set equal to dt at the beginning of the calculation, but it may
    be</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    reduced at any time-step, if accuracy requires it.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - vA and
    uA are the x- and y-speed of body A, given here their initial values.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - vB and
    uB are the x- and y-speed of body B, given here their initial values.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - xA0 and
    yA0 are variables that hold x- and y-coordinate values for body A.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - xB0 and
    yB0 are variables that hold x- and y-coordinate values for body B.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - xAB0 and
    yAB0 are variables that hold the x- and y-coordinate displacement</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    from body B to body A.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - rAB is
    the distance between bodies A and B.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - rAB3 is
    the cube of the distance between bodies A and B.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - kGravityA
    is the constant G*MA, where G is Newton's gravitational constant. This</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    influences the acceleration of body B.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - kGravityB
    is the constant G*MB, where G is Newton's gravitational constant. This</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    influences the acceleration of body A.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - axA0 and
    ayA0 are the x-acceleration and y-acceleration, respectively, of</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    body A at the location (xA0, yA0).</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - axB0 and
    ayB0 are the x-acceleration and y-acceleration, respectively, of</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    body B at the location (xB0, yB0).</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
    xCoordinateA
    and yCoordinateA are used to store the values of x and y of</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    body A at each timestep. They are arrays of length maxSteps.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
    xCoordinateB
    and yCoordinateB are used to store the values of x and y of</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    body B at each timestep. They are arrays of length maxSteps.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - xVelocityA
    and yVelocityA are used to store the values of the velocity</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    components v and u of body A at each timestep.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - xVelocityB
    and yVelocityB are used to store the values of the velocity</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    components v and u of body B at each timestep.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
    potentialEnergy
    and kineticEnergy are arrays that are used to store</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    the values of the potential and kinetic energy of the body, taking</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    its mass to equal 1. (The mass of the body is not needed for the</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    other calculations in this program, and since both energies are</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    simply proportional to the mass, the energies for any particular</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    body mass can be obtained by multiplying these values by</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    the mass after they are output from the program.)</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - time is
    an array that is used to store the value of the time</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    associated with the current position, as measured from the</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    beginning of the orbit.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double t = 0;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double dt1 = dt;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double vA = vInitA;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double uA = uInitA;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double vB = vInitB;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double uB = uInitB;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double xA0 = xInitA;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double yA0 = yInitA;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double xB0 = xInitB;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double yB0 = yInitB;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double xAB0 = xA0 -
    xB0;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double yAB0 = yA0 -
    yB0;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double rAB = Math.sqrt(
    xAB0*xAB0 + yAB0*yAB0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double rAB3 =
    rAB*rAB*rAB;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double kGravityA = MA
    * G;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double kGravityB = MB
    * G;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double axA0 =
    -kGravityB*xAB0/rAB3;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double ayA0 =
    -kGravityB*yAB0/rAB3;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double axB0 =
    kGravityA*xAB0/rAB3;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double ayB0 =
    kGravityA*yAB0/rAB3;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] xCoordinateA
    = new double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] yCoordinateA
    = new double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] xVelocityA
    = new double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] yVelocityA
    = new double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] xCoordinateB
    = new double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] yCoordinateB
    = new double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] xVelocityB
    = new double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] yVelocityB
    = new double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] potentialEnergy
    = new double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] kineticEnergy
    = new double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] time = new
    double[ maxSteps ];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xCoordinateA[0] = xA0;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yCoordinateA[0] = yA0;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xCoordinateB[0] = xB0;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yCoordinateB[0] = yB0;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now define
        other variables that will be needed, but without giving</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initial
        values. They will be assigned values during the calculation.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - xA1, yA1,
        xB1, and yB1 are temporary values of x and y for bodies A</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        and B, respectively, that are needed during the calculation.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - axA1,
        ayA1, axB1, and ayB1 are likewise temporary values of the acceleration.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - dxA, dyA,
        dxB, and dyB are variables that hold part of the changes in</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        x and y for bodies A and B, respectively, that occur during a time-step.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ddxA0,
        ddyA0, ddxA1, and ddyA1 are variables that hold other parts of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the changes in x and y of body A during a time-step. The reason for
        having</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        both dxA and ddxA will be explained in comments on the calculation
        below.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ddxB0,
        ddyB0, ddxB1, and ddyB1 are analogous variables for body B.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - dvA, duA,
        dvB, and duB are the changes in velocity components of bodies</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        A and B, respectively, that occur during a time-step.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - xAB1 and
        yAB1 are temporary values that hold the separations of the two</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        bodies.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
        testPrediction
        will hold a value that is used by the predictor-corrector</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        steps to assess how accurately the calculation is proceeding.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - angleNow
        holds the angular amount by which the planet has advanced in its</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        orbit at the current time-step.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - j and
        k are integers that will be used as loop counters.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double xA1, yA1, xB1,
        yB1, axA1, ayA1, axB1, ayB1, dvA, duA, dvB, duB;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double dxA, dyA, dxB,
        dyB, ddxA0, ddyA0, ddxB0, ddyB0, ddxA1, ddyA1, ddxB1, ddyB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double xAB1, yAB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double testPrediction,
        angleNow;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j, k;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Finally,
        we introduce some variables that are used to determine when</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body A
        completes
        a full orbit, so that the program can stop. This is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; done in
        the same way as in the program Orbit, where the method is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; more fully
        described. The difference here is that we compute the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orbital
        angular motion of A relative to B rather than relative to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the origin
        of coordinates. In the program Orbit, the "other body" --</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i.e. the
        Sun -- was at the coordinate origin, but that is not the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case here.
        What is relevant is the position relative to the other</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body, not
        to a fixed point in space that depends on how we choose</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the
        coordinates
        in the first place.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double angleInitPos
        = Math.atan2(yAB0, xAB0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double angleInitVel
        = Math.atan2(uInitA-uInitB, vInitA-vInitB);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double anglediff =
        angleInitVel
        - angleInitPos;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( anglediff &gt;
        Math.PI
        ) anglediff -= 2*Math.PI;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (anglediff &lt;
        -Math.PI) anglediff += 2*Math.PI;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean counterclockwise
        = ( anglediff &gt; 0 );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean fullOrbit =
        false;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean halfOrbit =
        false;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now start
        the loop that computes the two orbits. The loop counter</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is j, which
        (as in Orbit) starts at 1 and increases by 1 each</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; step. The
        test for exiting from the loop will be either that body</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A has gone
        once around, or that the number of steps exceeds</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the maximum
        set by the user. This latter test is important because</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some orbits
        do not close: if the initial velocity is too large the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bodies
        simply
        go off to larger and larger distances. The logical</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression
        that provides the test is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        !fullOrbit &amp;&amp; ( j &lt; maxSteps )</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note the
        use of the logical negation operator !: !fullOrbit is true</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when
        fullOrbit
        is false, i.e. before the end of the orbit, so it</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allows the
        loop to continue.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( j = 1; (
        !fullOrbit
        &amp;&amp; ( j &lt; maxSteps )); j++ ) {</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        - Set dvA and duA to the changes in x- and y-speeds that would occur</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        during time dt1 if the acceleration were constant at (axA0, ayA0),</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        and similarly for dvB and duB.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        - Similarly set dxA and dyA to the changes in position that would</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        occur if the velocity components vA and uA were constant during the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        time dt1, and similarly for dxB and dyB.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        - Set ddxA0 and ddyA0 to the extra changes in x and y that occur because</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        A's velocity changes during the time dt1. The velocity change that</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        is used is only dvA/2 (or duA/2, respectively) because the most</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        accurate change in position comes from computing the average</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        velocity during dt1. We separate the two position changes, dxA and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddxA0, because dxA will be unchanged when we do the predictor-corrector</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        below (the change in position due to the original speed is always</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        there), while ddxA0 will be modified when axA0 and hence dvA is modified</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        by the predictor-corrector. The handling of body B's variables is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        completely analogous.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        - Finally, set ddxA1 and ddyA1 to ddxA0 and ddyA0 initially. They will</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        change when we enter the predictor-corrector code. Do the similar</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        operations for ddxB1 and ddyB1.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dvA = axA0*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        duA = ayA0*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dxA = vA*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dyA = uA*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddxA0 = dvA/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddyA0 = duA/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddxA1 = ddxA0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddyA1 = ddyA0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dvB = axB0*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        duB = ayB0*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dxB = vB*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dyB = uB*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddxB0 = dvB/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddyB0 = duB/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddxB1 = ddxB0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddyB1 = ddyB0;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Now advance the position of body A by our initial estimates of the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        position changes, dxA + ddxA0 and dyA + ddyA0. Do the same for body</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        B. Then compute the new distance between the bodies and the resulting</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        accelerations there.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xA1 = xA0 + dxA + ddxA0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yA1 = yA0 + dyA + ddyA0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xB1 = xB0 + dxB + ddxB0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yB1 = yB0 + dyB + ddyB0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xAB1 = xA1 - xB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yAB1 = yA1 - yB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rAB = Math.sqrt( xAB1*xAB1 + yAB1*yAB1 );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rAB3 = rAB*rAB*rAB;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        axA1 = -kGravityB*xAB1/rAB3;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ayA1 = -kGravityB*yAB1/rAB3;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        axB1 = kGravityA*xAB1/rAB3;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ayB1 = kGravityA*yAB1/rAB3;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Time-step check.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        This is the code to check whether the time-step is too large. The idea</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        is to compare the changes in acceleration of body A during the timestep</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        with the acceleration of body A itself. We only deal with body A, since</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the test is likely to be similar for both bodies. If the change is too</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        large a fraction of the original value, then the step is likely to be</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        too large, and the resulting position too inaccurate. The code below
        cuts</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the time-step dt1 in half and then goes back to the beginning of the
        loop.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        How this works is explained more fully in the program Orbit.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if ( Math.abs(axA1-axA0) + Math.abs(ayA1-ayA0) &gt;
        eps1*(Math.abs(axA0) +
        Math.abs(ayA0)) ){</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dt1 /= 2;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        j--;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else {</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Predictor-corrector step. This is explained in program Orbit. Again,
        only
        the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        properties of the orbit of body A are used in the tests.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        testPrediction = Math.abs(ddxA0) + Math.abs(ddyA0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        for ( k = 0; k &lt; 10; k++ ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        /* compute dvA, duA, dvB, and duB by averaging the acceleration over
        dt1
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dvA = (axA0 + axA1)/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        duA = (ayA0 + ayA1)/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dvB = (axB0 + axB1)/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        duB = (ayB0 + ayB1)/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        /* compute ddxA1, ddyA1, ddxB1, and ddyB1 by averaging the velocity
        change
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddxA1 = dvA/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddyA1 = duA/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddxB1 = dvB/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddyB1 = duB/2*dt1;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Test the change in ddx and ddy since the last iteration.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        If it is more than a fraction eps2 of the original, then</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddx and ddy have to be re-computed by finding the acceleration</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        at the refined position.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        If the change is small enough, then the "else:" clause is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        executed, which exits from the for loop using the statement</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        "break". This finishes the iteration and goes on to wrap up</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the calculation.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if ( Math.abs(ddxA1-ddxA0) + Math.abs(ddyA1-ddyA0) &gt; eps2 *
        testPrediction
        ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Re-define ddxA0, ddyA0, ddxB0, and ddyB0 to hold the values</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        from the last iteration</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddxA0 = ddxA1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddyA0 = ddyA1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddxB0 = ddxB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddyB0 = ddyB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xA1 = xA0 + dxA + ddxA0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yA1 = yA0 + dyA + ddyA0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xB1 = xB0 + dxB + ddxB0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yB1 = yB0 + dyB + ddyB0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xAB1 = xA1 - xB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yAB1 = yA1 - yB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rAB = Math.sqrt( xAB1*xAB1 + yAB1*yAB1 );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rAB3 = rAB*rAB*rAB;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        axA1 = -kGravityB*xAB1/rAB3;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ayA1 = -kGravityB*yAB1/rAB3;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        axB1 = kGravityA*xAB1/rAB3;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ayB1 = kGravityA*yAB1/rAB3;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        We now have the "best" acceleration values, using the most</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        recent estimates of the position at the end of the loop.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        The next statement to be executed will be the first statement</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        of the "for" loop, finding better values of dvA, duA, ddxA1,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddyA1, and corresponding values for body B.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else break;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        The iteration has finished, and we have sufficiently accurate</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        values of the position change in ddxA1, ddyA1, ddxB1, and ddyB1.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Use them to get final values of xA, yA, xB, and yB at the end of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the time-step dt1 and store these into xA0, yA0, xB0, and yB0,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        respectively, ready for the next time-step. Compute all the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rest of the variables needed for the next time-step and for</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        possible data output.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        t += dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xA0 += dxA + ddxA1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yA0 += dyA + ddyA1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        axA0 = axA1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ayA0 = ayA1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        vA += dvA;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        uA += duA;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xCoordinateA[j] = xA0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yCoordinateA[j] = yA0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xVelocityA[j] = vA;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yVelocityA[j] = uA;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xB0 += dxB + ddxB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yB0 += dyB + ddyB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        axB0 = axB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ayB0 = ayB1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        vB += dvB;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        uB += duB;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xCoordinateB[j] = xB0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yCoordinateB[j] = yB0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xVelocityB[j] = vB;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yVelocityB[j] = uB;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xAB0 = xA0 - xB0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yAB0 = yA0 - yB0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rAB = Math.sqrt( xAB0*xAB0 + yAB0*yAB0 );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        potentialEnergy[j] = -kGravityA*MB/rAB;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        kineticEnergy[j] = 0.5*( MA*(vA*vA + uA*uA) + MB*(vB*vB + uB*uB));</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        time[j] = t;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Now test to see if the orbit has closed, i.e. if body A has gone</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        around body B once. We do this by the method described in the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        program Orbit, but as remarked above we use the location of body</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        A relative to body B.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        angleNow = Math.atan2(yAB0, xAB0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        anglediff = angleNow - angleInitPos;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if (anglediff &gt; Math.PI) anglediff -= 2*Math.PI;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else if (anglediff &lt; -Math.PI) anglediff += 2*Math.PI;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if (!halfOrbit) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if (counterclockwise) halfOrbit = (anglediff &lt; 0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else halfOrbit = (anglediff &gt; 0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if ( counterclockwise ) fullOrbit = (anglediff &gt; 0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else fullOrbit = fullOrbit = (anglediff &lt; 0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The orbit
        is finished. Now, as in previous programs, define arrays</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to contain
        the positions along the orbit with just the right size,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; so that
        no zeros are passed to the grapher. The value of j at this</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point is
        equal to the number of elements we need for the output arrays.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; But in this
        program, check which output choice has been made and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tailor the
        output to this choice. First-time programmers can safely</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ignore this
        section.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; In previous
        programs we have mainly used the Triana method "output()"</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for
        producing
        output from a unit. This works only if the unit has</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; just one
        output data set. In all the output cases here, we require</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; more than
        one data set to be output, so (as in the program Orbit) we</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use the
        more elaborate method "outputAtNode()", which allows us to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; specify
        which node will output which data. The node numbering</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; starts with
        0.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We attach
        to each output Curve a title (which will appear on the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graph
        legend),
        and we attach to the first output Curve the axis labels.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt><tt></tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
    (outputType.equals("orbit"))
    {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalXA = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalYA = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalXB = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalYB = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalXA[k] = xCoordinateA[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalYA[k] = yCoordinateA[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalXB[k] = xCoordinateB[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalYB[k] = yCoordinateB[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out0 = new Curve( finalXA, finalYA );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setTitle("Orbit of Body A");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setIndependentLabels(0,"x (m)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setDependentLabels(0,"y (m)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out1 = new Curve( finalXB, finalYB );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out1.setTitle("Orbit of Body B");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 0, out0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 1, out1 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
    (outputType.equals("velocity
    space")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalVA = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalUA = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalVB = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalUB = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalVA[k] = xVelocityA[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalUA[k] = yVelocityA[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalVB[k] = xVelocityB[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalUB[k] = yVelocityB[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out0 = new Curve( finalVA, finalUA );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setTitle("Velocity Plot of Body A");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setIndependentLabels(0,"V (m/s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setDependentLabels(0,"U (m/s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out1 = new Curve( finalVB, finalUB );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out1.setTitle("Velocity Plot of Body B");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 0, out0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 1, out1 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
    (outputType.equals("position
    vs. time, body A")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalXA = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalYA = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalT = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalXA[k] = xCoordinateA[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalYA[k] = yCoordinateA[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalT[k] = time[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out0 = new Curve( finalT, finalXA );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setTitle("X(t) for Body A");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setIndependentLabels(0,"t (s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setDependentLabels(0,"position (m)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out1 = new Curve( finalT, finalYA );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out1.setTitle("Y(t) for Body A");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 0, out0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 1, out1 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
    (outputType.equals("position
    vs. time, body B")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalXB = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalYB = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalT = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalXB[k] = xCoordinateB[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalYB[k] = yCoordinateB[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalT[k] = time[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out0 = new Curve( finalT, finalXB );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setTitle("X(t) for Body B");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setIndependentLabels(0,"t (s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setDependentLabels(0,"position (m)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out1 = new Curve( finalT, finalYB );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out1.setTitle("Y(t) for Body B");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 0, out0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 1, out1 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
    (outputType.equals("velocity
    vs. time, body A")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalVA = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalUA = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalT = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalVA[k] = xVelocityA[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalUA[k] = yVelocityA[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalT[k] = time[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out0 = new Curve( finalT, finalVA );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setTitle("V(t) for Body A");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setIndependentLabels(0,"t (s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setDependentLabels(0,"speed (m/s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out1 = new Curve( finalT, finalUA );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out1.setTitle("U(t) for Body A");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 0, out0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 1, out1 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
    (outputType.equals("velocity
    vs. time, body B")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalVB = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalUB = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalT = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalVB[k] = xVelocityB[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalUB[k] = yVelocityB[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalT[k] = time[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out0 = new Curve( finalT, finalVB );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setTitle("V(t) for Body B");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setIndependentLabels(0,"t (s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setDependentLabels(0,"speed (m/s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out1 = new Curve( finalT, finalUB );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out1.setTitle("U(t) for Body B");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 0, out0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 1, out1 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
    (outputType.equals("energy
    vs time")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalP = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalK = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalE = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalT = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalP[k] = potentialEnergy[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalK[k] = kineticEnergy[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalE[k] = finalP[k] + finalK[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalT[k] = time[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out0 = new Curve( finalT, finalP );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setTitle("Potential energy vs time");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setIndependentLabels(0,"t (s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setDependentLabels(0,"energy (J)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out1 = new Curve( finalT, finalK );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out1.setTitle("Kinetic energy vs time");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out2 = new Curve( finalT, finalE );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out2.setTitle("Total energy vs time");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 0, out0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 1, out1 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 2, out2 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    &nbsp;
    <br>
    &nbsp;
</p>

<p></p>
<hr width="15%" size="4">
<br>
<b><font size="-1">Return to <a href="index.html">index</a> of all
    computer
    programs.</font></b>
</body>
</html>
