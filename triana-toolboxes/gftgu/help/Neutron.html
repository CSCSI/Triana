<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    <meta name="Generator" content="Microsoft Word 97">
    <meta name="Template"
          content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
    <meta name="GENERATOR"
          content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
    <meta name="Author" content="Bernard F Schutz">
    <title>Neutron</title>
</head>
<body text="#000000" bgcolor="#fdf5e6" link="#808080" vlink="#808080"
      alink="#ff0000" background="BH-posneg.negative.watermark.png">
<span style="font-weight: bold;"><a href="license.html"><img
        src="HelpfileBanner.png" title="Click to view license information."
        alt="" style="border: 0px solid ; width: 375px; height: 362px;"
        align="right"></a></span><br>
<table cellpadding="2" cellspacing="2" border="3"
       style="text-align: left; width: 50%; margin-left: auto; margin-right: auto;">
    <tbody>
    <tr>
        <td
                style="vertical-align: top; background-color: rgb(204, 204, 204);">
            <h3
                    style="color: rgb(102, 255, 153); font-family: monospace; font-weight: bold; text-align: center;">
                <big><big><big><big><span
                        style="color: rgb(255, 0, 0);">Neutron</span></big></big></big></big></h3>

            <div style="text-align: center;"><big><font size="+2"><big><span
                    style="color: rgb(255, 0, 0);"><small><span style="font-weight: bold;"><small><span
                    style="color: rgb(0, 0, 0);">version 1.0<br>
      </span></small></span></small></span></big></font><big><big><span
                    lang="EN-GB"
                    style="font-size: 12pt; font-family: &quot;Times New Roman&quot;; font-weight: bold;">&copy;
                2003 Bernard Schutz</span></big></big></big><br>
            </div>
            <h3
                    style="font-family: helvetica,arial,sans-serif; text-align: center;">
                <large><b><span
                        style="color: rgb(0, 0, 0);">Build a model of a neutron star using the
full structure equations of general relativity. The user can choose the
central pressure and some aspects of the equation of state. The program
will output graphs of the density, pressure, or mass as functions of
the radius.<br>
      </span></b></large>
            </h3>
        </td>
    </tr>
    </tbody>
</table>
<p><br>
</p>

<h2><a name="contents"></a>Contents</h2>
<ul>
    <li>
        <a href="#description">Description of <tt><font size="+1">Neutron</font></tt></a></li>
    <li>
        <a href="#using">Using <tt><font size="+1">Neutron</font></tt></a></li>
    <li>
        <a href="#playing">Suggestions for playing with <tt><font size="+1">Neutron</font></tt></a></li>
    <li>
        <a href="#understanding">Understanding <tt><font size="+1">Neutron</font></tt></a></li>
    <li>
        <a href="#suggestions">Suggested modifications of <tt><font
                size="+1">Neutron</font></tt></a></li>
    <li>
        <a href="#listing">Listing of the Java code for <tt><font size="+1">Neutron</font></tt></a></li>
    <br>
    &nbsp;
    <p>&nbsp;
        <br>
        &nbsp;
        <br>
        &nbsp;
    </p>

    <p></p>
    <hr width="15%" size="4">
</ul>
<h2>
    <a name="description"></a>Description of <tt><font size="+3">Neutron</font></tt></h2>
The unit called <tt><font size="+1">Neutron</font></tt> implements the
Java
program for computing the structure of a neutron star. It is a
modification
of the program <tt><font size="+1"><a href="Star.html">Star</a></font></tt>,
in which the Newtonian equation of hydrostatic equilibrium (the neutral
buoyancy equation) is replaced by its counterpart in general
relativity.
The rest of the program is similar to <tt><font size="+1">Star</font></tt>,
with one exception: in neutron stars, temperature is not important,
because
the pressure comes from quantum effects between neutrons rather than
from
thermal motions of particles. Therefore, the user is not asked to
specify
a central temperature for the star; instead, the program needs directly
the proportionality constant <i>k</i> in the polytropic equation of
state,
<i>p</i>
= <i>k <font face="SymbolPS">r<sup>g</sup></font></i>. The value of <i>k</i>
must be calculated from the basic physics of neutrons and protons.
<p>The program allows users to see directly that the relatively small
    changes
    that relativity makes in the structure equation, which are described in
    Investigation 20.3, lead to the existence of an upper limit on the mass
    of a neutron star. By increasing the central density and finding the
    point
    where the mass of the star stops increasing and starts to decrease, the
    user can determine the point of onset of instability: this is the
    densest
    a neutron star can be, and the most massive (for the assumed equation
    of
    state, of course).
</p>

<p></p>
<hr width="15%" size="4">
<h2><a name="using"></a>Using <tt><font size="+3">Neutron</font></tt></h2>
Simply drag the <tt><font size="+1">Neutron</font></tt> icon from the
toolbox
into the working area, drag the <tt><font size="+1">SGTGrapher</font></tt>
unit into the area, and connect the two if Triana has not already done
so. If you press the <tt><font size="+1">Start</font></tt> button then
the
program will execute with its default settings, producing a model of a
neutron star, as given by its pressure as a function of radius. Because
the pressure falls off quickly with radius, you will get a better plot
if you use a logarithmic scale for the vertical axis. Choose this from
the "<tt><font size="+1">Plot</font></tt>" menu of <tt><font size="+1">SGTGrapher</font></tt>.
<p><img src="imageSHH.JPG" height="176" width="564" align="left">The
    parameter
    window shown here allows the user to determine what kind of star is
    being
    modelled. The first parameter is the polytropic exponent <i><font
            face="SymbolPS">g</font></i>.
    The default value is the one that gives the best fit to the detailed
    nuclear
    physics calculations of the equation of state of dense neutron matter:
    <i><font face="SymbolPS">g</font></i>
    = 5/3.&nbsp; The second parameter is the central pressure of the star,
    in pascals. The third is the proportionality constant <i>k</i> in the
    equation
    of state. The pressure and constant <i>k</i> together determine the
    structure
    of the star: its mass and radius.
</p>

<p><img src="image04J.JPG" height="85" width="81" align="left">The
    final parameter
    is a drop-down list (choice box) that allows the user to choose what
    data
    is actually output. To find the mass of the star, for example, you
    should
    output the mass as a function of radius and read off the maximum value,
    which occurs at the surface of the star.
</p>

<p></p>
<hr width="15%" size="4">
<h2><a name="playing"></a>Suggestions for playing with <tt><font
        size="+3">Neutron</font></tt></h2>
The parameters given by default are those that produce a fair
approximation
to the current best models of neutron stars. The polytropic exponent
should
be between 3/2 and 5/3 for realistic equations of state. You should
choose
the constant of proportionality (for any choice of the exponent) to
ensure
that a star whose central density is the nuclear density has a mass of
about 1 solar mass. For any of these equations of state, change the
central
pressure and record the mass of the star. Verify for yourself that all
these sequences reach a maximum of the mass, after which the mass
begins
to decrease with increasing central pressure. Can you build a sequence
with a maximum mass larger than 2 solar masses? Larger than 3 solar
masses?
<p>The computer program will produce arbitrarily small-mass stars if
    you
    choose the central pressure smaller. Try this to see if you can get
    something
    smaller than the 0.02 solar masses that we estimated was the minimum
    for
    a neutron star. Does this mean that our discussion in Investigation
    20.1
    was wrong? Hint: the answer lies in the simplicity of the assumed
    equation
    of state that the computer program uses. What key physics does it leave
    out?
</p>

<p>Look up on the internet descriptions of "strange stars" or "strange
    quark" stars. These are stars where the neutrons have transmuted into
    more
    exotic nuclear matter, and they can achieve smaller radii for given
    masses.
    Find suitable values for the parameters and use the program to
    construct
    quark stars. Show that these, too, have a maximum mass. Can you get
    above
    3 solar masses with them?
</p>

<p>Another way to play with the program is to assume we know nothing
    about
    nuclear physics, and so the constants given as parameters can be
    anything
    at all. While this will lead to neutron stars of large masses, if you
    choose
    the parameters in the right way, there is one rule that all your models
    will obey: no star will have a gravitational radius 2<i>GM/c</i><sup>2</sup>
    larger than 8/9 of its physical radius. Recall that a black hole is
    formed
    if the star's physical radius shrinks to the size of its gravitational
    radius. Thus, there is a small gap between 8/9 and 1 where there are no
    static stellar models, no matter what equation of state you assume.
    This
    result is called Buchdahl's theorem. Try to break it!
</p>

<p>You can make a test of the consistency of general relativity in weak
    gravitational fields with Newtonian gravity by trying to build a model
    of a normal star. After all, if general relativity is the right theory
    of gravity, then the relativistic structure equation should be the
    right
    one even for normal stars. Choose parameters to match a model you
    constructed
    for the Sun using the program <tt><font size="+1">Star</font></tt>.
    You will
    have to use the central temperature that is required by <tt><font
            size="+1">Star</font></tt>
    to compute the value of the porportionality constant k appropriate to
    the
    solar model. Use that value in <tt><font size="+1">Neutron</font></tt>,
    with
    the central pressure and polytropic exponent you used in <tt><font
            size="+1">Star</font></tt>,
    and see if you can see any differences between the stellar models.
    There
    should not be any significant changes!
</p>

<p></p>
<hr width="15%" size="4">
<h2><a name="understanding"></a>Understanding <tt><font size="+3">Neutron</font></tt></h2>
The modification of the equation of hydrostatic equilibrium for general
relativity is discussed in Investigation 20.3. The most implementation
of this equation is straightforward, since it involves no quantities
that
are not in the program <tt><font size="+1">Star</font></tt>. The
treatment
of the equation of state is, if anything, easier than in <tt><font
        size="+1">Star</font></tt>
<br>
because there is no need to compute <i>k</i> in the preliminary code:
it is given as a parameter by the user.
<p></p>
<hr width="15%" size="4">
<h2><a name="suggestions"></a>Suggested modifications of <tt><font
        size="+3">Neutron</font></tt></h2>
As with the program <tt><font size="+1">Star</font></tt>, you could
modify
Neutron to deal with equations of state which change through the star.
Alternatively, simply do what professional physicists do: provide a
table
of values of pressure against density for nuclear matter (which you
could
find on the internet or in some advanced text books), and instead of
using
a simple polytrope to compute the density as a function of pressure,
look
it up in your table. Since tables can be built only with finite steps
in
pressure, you will have to interpolate between them, much as we did
interpolation
on temperature in the program <tt><font size="+1">Atmosphere</font></tt>.
<p>If you want to change the program you will have to re-compile it, as
    explained by the help file <a href="UsingTriana.html">Using Triana for
        <i>Gravity
            from the ground up</i></a>.
    <br>
    &nbsp;
</p>

<h2>
    <hr width="15%" size="4">
</h2>
<h2>
    <a name="listing"></a>Listing of the Java code for <tt><font size="+3">Neutron</font></tt></h2>

<h3>
    Preliminary definitions of parameters and constants</h3>

<p><br>
    <tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gamma is the polytropic exponent
        in the equation of state relating</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pressure and density: pressure is
        proportional to (density)^(gamma).</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It is given by the user in the user
        interface window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double gamma;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pC is the central pressure of the
        star, in pascals. It is given by</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the user in the user interface
        window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double pC;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; K is the proportionality constant
        in the equation of state, relating</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pressure to density^gamma. It is
        given by the user in the user</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double K;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputType is a String which governs
        what kind of data will be</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output. All data is output as a
        Curve with x-values being the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radial distance and y-values being
        one of three choices: pressure,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; density, or mass. In this case,
        "mass" means "relativistic mass</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interior to the given radius". The
        user
        chooses one of these four</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in the user interface window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private String outputType;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Two constants needed in the
        calculation,
        in SI units:</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - G is Newton's gravitational
        constant</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - c2 is the square of the speed
        of light.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double G = 6.672e-11;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double c2 = 8.98755e16;</tt>
    <br>
    &nbsp;
    <br>
    &nbsp;
</p>

<h3>Program code</h3>

<p><br>
    <tt>&nbsp;&nbsp;&nbsp; public void process() throws Exception {</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Define
        variables
        needed for the calculation:</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - gammaRecip
        is the reciprocal of gamma, 1/gamma.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - rhoC is
        the density at the center of the star.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - scale
        is the scale-height of the pressure, roughly the distance</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        over which the pressure will fall by a factor of 2.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - dr is
        the size of the step in radius that the program will make.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - arrays
        radius, p (pressure), rho (density), and mass (relativistic</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        mass function inside the star) hold the values of the associated</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        physical quantities at the successive radial steps. The arrays</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        are initially given 2000 elements. The choice of radial step dr</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        is designed to ensure that the surface of the star (where p = 0)</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        is reached in fewer than 2000 steps. Then give the values of the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        first elements of the arrays.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - lastStep
        is an int that will hold the value of the array index</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        associated with the surface of the star. Set it to zero and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        use it as a test of whether the surface has been reached (see below).</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - j is a
        loop counter.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double gammaRecip =
        1.0 / gamma;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double rhoC =
        Math.pow(pC
        / K, gammaRecip);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale =
        Math.sqrt(pC
        / G) / rhoC;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double dr = scale /
        400.;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] radius = new
        double[2000];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] p = new
        double[2000];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] rho = new
        double[2000];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] mass = new
        double[2000];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radius[0] = 0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p[0] = pC;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rho[0] = rhoC;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mass[0] = 0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int lastStep = 0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j;</tt>
    <br>
    &nbsp;
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Do the
        calculation
        as long as the top has not been reached.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( lastStep ==
        0 ) {</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        As described in the text, we cannot start the loop accurately with the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        first points. Instead we compute the values of pressure etc at the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        first non-zero radial step (radius[1] = dr) by the approximations given</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        in the text.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        radius[1] = dr;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        p[1] = pC;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rho[1] = rhoC;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        mass[1] = 4.0 * Math.PI * dr * dr * dr * rhoC/ 3.0;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Do calculation step by step, using the equation of hydrostatic</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        equilibrium (in the second line of the loop).</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        for ( j = 2; j &lt; 2000; j++ ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        radius[j] =&nbsp; radius[j-1] + dr;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        p[j] = p[j-1] - G * ( rho[j-1] + p[j-1]/c2 ) * ( mass[j-1] +
        4*Math.PI*Math.pow(radius[j-1],3)/c2
        ) * dr / (radius[j-1] * ( radius[j-1] - 2*G*mass[j-1]/c2) );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if ( p[j] &lt; 0 ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        lastStep = j; //stop when the pressure goes negative</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        break;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        mass[j] =&nbsp; mass[j-1] + 4 * Math.PI * radius[j-1] * radius[j-1] *
        rho[j-1]
        * dr;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rho[j] = Math.pow( p[j]/K, gammaRecip);&nbsp; //polytropic equation of
        state</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        If we reach this point and lastStep is still zero, then we have</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        used 2000 steps and not yet reached the surface. We must start the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        loop again with a larger step dr so that we can reach the surface in</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        2000 steps. The next line of the code resets the value of dr, and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        then when we reach the end-bracket of the "while"-loop the test</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        in the loop will evaluate to true and the "for"-loop will be</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        done again with this step-size.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        If we reach this point and lastStep is no longer zero, then we</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        have finished the calculation. The next step (changing dr) will be</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        executed but we will leave the "while"-loop and so the new value</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        of dr will not be used.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dr *= 2.;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now prepare
        output arrays depending on what output data type has</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; been
        selected
        by the user. The arrays are only long enough to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contain
        the number of points to the surface of the star. Since</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the value
        of the variable lastStep is the step where the pressure</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first went
        negative, if we create arrays of length lastStep then</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this value
        will be excluded, since such arrays start at index 0</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and finish
        at index lastStep-1.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] finalR = new
    double[lastStep];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Curve outData =&nbsp;
        null;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String unitLabel = "";</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
    (outputType.equals("Pressure"))
    {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        double[] finalP = new double[lastStep];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        for ( j = 0; j &lt; lastStep; j++ ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalR[j] = radius[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalP[j] = p[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData =&nbsp; new Curve( finalR, finalP );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        unitLabel = " (Pa)";</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
        (outputType.equals("Density"))
        {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        double[] finalRho = new double[lastStep];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        for ( j = 0; j &lt; lastStep; j++ ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalR[j] = radius[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalRho[j] = rho[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData = new Curve( finalR, finalRho );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        unitLabel = " (kg/m^3)";</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
        (outputType.equals("Mass"))
        {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        double[] finalM = new double[lastStep];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        for ( j = 0; j &lt; lastStep; j++ ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalR[j] = radius[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalM[j] = mass[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData = new Curve( finalR, finalM );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        unitLabel = " (kg)";</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData.setTitle(outputType);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData.setIndependentLabels(0,"altitude
        (m)");</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData.setDependentLabels(0,outputType
        + unitLabel);</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output( outData );</tt>
    <br>
    &nbsp;
</p>

<p><tt>&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    &nbsp;
    <br>
    &nbsp;
    <br>
    &nbsp;
</p>

<p></p>
<hr width="15%" size="4">
<br>
<b><font size="-1">Return to <a href="index.html">index</a> of all
    computer
    programs.</font></b>
</body>
</html>
