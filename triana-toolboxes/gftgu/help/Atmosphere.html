<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    <meta name="Generator" content="Microsoft Word 97">
    <meta name="Template"
          content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
    <meta name="GENERATOR"
          content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
    <meta name="Author" content="Bernard F Schutz">
    <meta name="Description"
          content="Help file for Triana unit RelativisticOrbit, part of the toolbox for the book Gravity from the Ground Up.This unit computes the structure of the atmosphere of the Earth or a planet.">
    <meta name="KeyWords"
          content="Gravity from the ground up, Triana, help file">
    <title>Atmosphere</title>
</head>
<body text="#000000" bgcolor="#fdf5e6" link="#808080" vlink="#808080"
      alink="#ff0000" background="BH-posneg.negative.watermark.png">
<span style="font-weight: bold;"><a href="license.html"><img
        src="HelpfileBanner.png" title="Click to view license information."
        alt="" style="border: 0px solid ; width: 375px; height: 362px;"
        align="right"></a></span><br>
<table cellpadding="2" cellspacing="2" border="3"
       style="text-align: left; width: 50%; margin-left: auto; margin-right: auto;">
    <tbody>
    <tr>
        <td
                style="vertical-align: top; background-color: rgb(204, 204, 204);">
            <h3
                    style="color: rgb(102, 255, 153); font-family: monospace; font-weight: bold; text-align: center;">
                <big><big><big><big><span
                        style="color: rgb(255, 0, 0);">Atmosphere<br>
      </span></big></big></big></big></h3>

            <div style="text-align: center;"><big><font size="+2"><big><span
                    style="color: rgb(255, 0, 0);"><small><span style="font-weight: bold;"><small><span
                    style="color: rgb(0, 0, 0);">version 1.0<br>
      </span></small></span></small></span></big></font><big><big><span
                    lang="EN-GB"
                    style="font-size: 12pt; font-family: &quot;Times New Roman&quot;; font-weight: bold;">&copy;
                2003 Bernard Schutz</span></big></big></big><br>
            </div>
            <h3
                    style="font-family: helvetica,arial,sans-serif; text-align: center;">
                <large><b><span
                        style="color: rgb(0, 0, 0);">Compute the structure of the atmosphere
of the Earth or of other planets and moons in the Solar System. Find
the way the density and pressure depend on altitude.<br>
      </span></b></large>
            </h3>
        </td>
    </tr>
    </tbody>
</table>
<h2><a name="contents"></a>Contents</h2>
<ul>
    <li>
        <a href="#description">Description of <tt><font size="+1">Atmosphere</font></tt></a></li>
    <li>
        <a href="#using">Using <tt><font size="+1">Atmosphere</font></tt></a></li>
    <li>
        <a href="#playing">Suggestions for playing with <tt><font size="+1">Atmosphere</font></tt></a></li>
    <li>
        <a href="#understanding">Understanding <tt><font size="+1">Atmosphere</font></tt></a></li>
    <li>
        <a href="#suggestions">Suggested modifications of <tt><font
                size="+1">Atmosphere</font></tt></a></li>
    <li>
        <a href="#listing">Listing of the Java code for <tt><font size="+1">Atmosphere</font></tt></a></li>
</ul>
<hr width="15%" size="4">
<h2><a name="description"></a>Description of <tt><font size="+3">Atmosphere</font></tt></h2>
The unit called <tt><font size="+1">Atmosphere</font></tt> implements
the
Java program for computing the structure of a planetary atmosphere,
like
the Earth's. It uses the principle of neutral buoyancy (called the
equation
of hydrostatic equilibrium) to compute the change of pressure and
density
with height. It requires the user to provide a temperature profile of
the
atmosphere with height, and it uses this in the ideal gas law to make a
unique relationship between pressure and temperature. The physics of
this
is described in Investigation 7.1. The principles of the computer
program
are described in Investigation 7.3. Temperature profiles for a number
of
solar system bodies are given in Table 7.1.
<p>The program gives a good model of the atmosphere except at its top,
    where the physics is more complex than we can capture in the ideal gas
    law.
    <br>
    &nbsp;
</p>

<h2>
    <hr width="15%" size="4">
</h2>
<h2>
    <a name="using"></a>Using <tt><font size="+3">Atmosphere</font></tt></h2>
Simply drag the <tt><font size="+1">Atmosphere</font></tt> icon from
the
toolbox into the working area, drag the <tt><font size="+1">SGTGrapher</font></tt>
unit into the area, and connect the two if Triana has not already done
so. If you press the <tt><font size="+1">Start</font></tt> button then
the
program will execute with its default settings, producing a model of
the
Earth's atmosphere as given by its pressure as a function of altitude.
Because the pressure falls off quickly with altitude, you will get a
better
plot if you use a logarithmic scale for the vertical axis. Choose this
from the "<tt><font size="+1">Plot</font></tt>" menu of <tt><font
        size="+1">SGTGrapher</font></tt>.
<p><img src="imageQQV.JPG" height="222" width="653" align="left">The
    parameter
    window of <tt><font size="+1">Atmosphere</font></tt> (shown here)
    allows
    the user to choose different planets. The first parameter is for the
    name
    of the body. The second is the surface gravitational acceleration,
    which
    is assumed constant over the height of the atmosphere. The third is the
    mean molecular weight of the gas in the atmosphere, which depends on
    its
    composition. This is a number that is given in Table 7.1 for several
    bodies.
    The fourth parameter is the surface pressure, which the user should
    also
    take from the table. The fifth parameter is a list of values of the
    temperature
    at different heights in the atmosphere, where the heights are given in
    meters and the temperature in absolute Kelvins. the list must have the
    form of pairs of numbers within parentheses, separated by commas. The
    pairs
    are separated only by optional spaces. You can give as many such
    measurements
    as you have available. The program will use interpolation (see <a
            href="#understanding">below</a>)
    to find temperature values in between the measured locations.
</p>

<p><img src="image9DA.JPG" height="81" width="102" align="left">The
    final parameter
    is a drop-down list (called a choice box) where the user chooses what
    function
    to output: pressure, density, or temperature in the model atmosphere. W<tt>hen
        you select the list it looks like the image at the left. Each of these
        has different units and a different scale, so they are not designed to
        be plotted on a </tt>single graph. Just plot each in turn for the same
    parameters that determine the model.
    <br>
    &nbsp;
</p>

<h2>
    <hr width="15%" size="4">
</h2>
<h2>
    <a name="playing"></a>Suggestions for playing with <tt><font size="+3">Atmosphere</font></tt></h2>
You should run the program for the Earth and the bodies given in Table
7.1. Data for other solar system bodies is available on various
websites,
if you wish to model their atmospheres. But do not try to model the
structure
of Jupiter or the other "gas giant" planets, since they are almost all
gas, and therefore the gravitational acceleration varies from place to
place in their atmospheres. The main purpose of <tt><font size="+1">Atmosphere</font></tt>
is to introduce and verify the basic technique of handling the equation
of hydrostatic equilibrium in a simple case; to do a better job on real
atmospheres we would have to put into the program much more physics and
chemistry, and even dynamics (i.e. weather). We will soon generalize <tt><font
        size="+1">Atmosphere</font></tt>
to the much more varied subject of stellar structure, with the program
<tt><font size="+1"><a href="Star.html">Star</a></font></tt>.
<br>
&nbsp;
<p></p>
<hr width="15%" size="4">
<h2><a name="understanding"></a>Understanding <tt><font size="+3">Atmosphere</font></tt></h2>
<tt><font size="+1">Atmosphere</font></tt> computes the atmosphere by
making
small but finite steps in altitude. The principle is that the gas
contained
in the small step should be in neutral buoyancy: the pressure
difference
between its bottom and top should exactly equal its weight. The weight
can be computed from the density, which in turn is defined by the
temperature,
molecular weight, and pressure. In principle we just take finite steps
upward until the pressure falls to zero. All of this is described in
more
detail in Investigations 7.1 and 7.3.
<p>Like the dynamical program <tt><font size="+1"><a href="Orbit.html">Orbit</a></font></tt>,
    this program includes a loop. In this loop we step upwards in altitude
    rather than forwards in time. The equation of hydrostatic equilibrium
    (Equation
    7.1) is implemented by the following code within this loop:
    <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        p[j] = p[j-1] - gAccel * rho[j-1] * dh;</font></tt>
    <br>
    The pressure drops by the buoyancy force needed to support the weight
    of the next layer of gas. However, before we can go on to the next step
    in altitude, we have to get the density at the current level from the
    pressure
    we have just computed. This requires the ideal gas law and a value for
    the temperature. Given those, the line we use is
    <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rho[j] = p[j] * q / Temp[j];</font></tt>
    <br>
    where <tt><font size="+1">q</font></tt> is a variable that contains
    all
    the constants in this equation and <tt><font size="+1">Temp</font></tt>
    is
    an array giving the value of the temperature at the current height.
    This
    temperature is not trivial to compute, since generally speaking there
    is
    no measurement at the given height. The program uses a special method,
    called <tt><font size="+1">getTemp</font></tt>, to interpolate between
    measured
    values. (Its code is reproduced below.) The way this is done is
    described
    in Investigation 7.3, with one addition: above the height of the
    highest
    measurement, there is no further point for interpolation, so the
    program
    finishes off the height of the atmosphere by assuming a power-law
    relation
    between density and pressure, for no particularly good reason except to
    keep the program simple and the extent of the atmosphere finite.
</p>

<p>The program has to stop when it finds the top of the atmosphere,
    which
    is where the pressure goes to zero. It checks for this at each step of
    the loop. If the program does not reach the top in the finite number of
    steps specified, then it will execute again with a larger step size.
    Therefore
    the "<tt><font size="+1">for</font></tt>" loop for stepping upwards in
    height
    is enclosed within a "<tt><font size="+1">while</font></tt>" statement
    which
    looks at the value of the integer lastStep, which starts out zero and
    is
    only made positive when the last step has been reached.
    <br>
    &nbsp;
</p>

<p></p>
<hr width="15%" size="4">
<h2><a name="suggestions"></a>Suggested modifications of <tt><font
        size="+3">Atmosphere</font></tt></h2>
The most obvious way to change the program is to allow gravity to vary
with height. This is something we do in the next program in this
series,
<a href="Star.html">Star</a>.
<br>
&nbsp;
<p></p>
<hr width="15%" size="4">
<h2><a name="listing"></a>Listing of the Java code for <tt><font
        size="+3">Atmosphere</font></tt></h2>

<h3>
    Preliminary definitions of parameters and constants</h3>
<tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; planetName is a String given by
    the user, which will be used as a name</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for the output graph.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; */</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp; private String planetName;</tt>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gAccel is the value of the
        acceleration
        of gravity at the surface of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the planet (bottom of the
        atmosphere),
        in SI units (m/s^2). Given by</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the user in the user interface
        window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double gAccel;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mu is the mean molecular weight
        of the atmospheric gas, which is defined</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as the average mass, in units of
        the proton mass, of all the atoms,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; molecules, ions, electrons, etc
        that move freely in the atmosphere.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It is given by the user in the user
        interface window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double mu;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p0 is the pressure of the atmosphere
        at its base (the surface of the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; planet), in pascals. Given by the
        user in the user interface window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double p0;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temperatureArray is a String that
        contains the temperature as a</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function of altitude. This is given
        by the user in the user</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interface window, in the form
        (h0,T0)
        (h1,T1) (h2,T2) ..., where</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h is in meters and T in kelvin.
        The program converts this into</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; two double arrays h and T.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private String temperatureArray;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputType is a String which governs
        what kind of data will be</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output. All data is output as a
        Curve with x-values being the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; altitude and y-values being one
        of three choices: pressure,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; density, or temperature. The user
        chooses one of these three</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in the user interface window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private String outputType;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Define double arrays h, T that hold
        the numerical values of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the altitude at which the
        temperature
        is given (h[]) and the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values of the temperature at those
        altitudes (T[]). These</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arrays are re-defined and given
        values each time the parameter</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temperatureArray is set.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Define the int measurements to hold
        the length of these arrays.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double[] h,T;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private int measurements;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Two constants: k is Boltzmann's
        constant and mp is the mass of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the proton, both in SI units.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double k = 1.38e-23;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double mp = 1.67e-27;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Three constants used for the
        computation
        of the temperature at</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the top of the atmosphere, above
        the highest altitude where the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temperature has been measured.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - reachedTop is a boolean that is
        set to false each time</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; process() is called,
        and is then used by the method getTemp().</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; See the comments in
        getTemp() below for details.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - power and beta are the constants
        in the formula for the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temperature in the upper
        region, T = beta * p^(power), where</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p is the pressure at
        that height and where "^" indicates raising</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to a power. We fix the
        value of power here, but the value of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beta must be computed
        during the calculation. See the comments</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in getTemp() below for
        details.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private boolean reachedTop = false;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double power = 0.5;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double beta;</tt>
    <br>
    &nbsp;
</p>

<h3>Program code</h3>
<tt>&nbsp;&nbsp;&nbsp; public void process() throws Exception {</tt>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Define
        variables
        needed for the calculation:</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - q is a
        combination of constants in the ideal gas law, used often.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - rho0 is
        the density at the bottom of the atmosphere.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - scale
        is the scale-height of the atmosphere, roughly the distance</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        over which the pressure will fall by a factor of 2.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - dh is
        the size of the step in altitude that the program will make.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - arrays
        alt (height), p (pressure), rho (density), and Temp (temperature)</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        hold the values of the associated physical quantities at the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        successive altitude steps. The arrays are initially given 1000</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        elements. The choice of altitude step dh is designed to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ensure that the top of the atmosphere (where p = 0) is reached</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        in fewer than 1000 steps. Then give the values of the first</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        elements of the arrays.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - lastStep
        is an int that will hold the value of the array index</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        associated with the top of the atmosphere. Set it to zero and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        use it as a test of whether the top has been reached (see below).</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - j is a
        loop counter.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double q = mp * mu /
        k;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double rho0 = p0 * q
        / T[0]; //use ideal gas law to get density</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double scale = p0 /
        gAccel / rho0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double dh = scale /
        200.;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] alt = new
        double[1000];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] p = new
        double[1000];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] rho = new
        double[1000];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] Temp = new
        double[1000];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alt[0] = 0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p[0] = p0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temp[0] = T[0];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rho[0] = rho0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int lastStep = 0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set
        reachedTop
        to false at the beginning of the computation.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reachedTop = false;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Do the
        calculation
        as long as the top has not been reached.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( lastStep ==
        0 ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Do calculation step by step, using the equation of hydrostatic</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        equilibrium (in the second line of the loop).</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        for ( j = 1; j &lt; 1000; j++ ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        alt[j] =&nbsp; alt[j-1] + dh;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        p[j] = p[j-1] - gAccel * rho[j-1] * dh;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if ( p[j] &lt; 0 ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        lastStep = j; //stop when the pressure goes negative</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        break;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Temp[j] = getTemp( alt[j], p[j] );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        rho[j] = p[j] * q / Temp[j];&nbsp; //ideal gas law</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        If we reach this point and lastStep is still zero, then we have</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        used 1000 steps and not yet reached the top. We must start the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        loop again with a larger step dh so that we can reach the top in</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        1000 steps. The next line of the code resets the value of dh, and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        then when we reach the end-bracket of the "while"-loop the test</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        in the loop will evaluate to true and the "for"-loop will be</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        done again with this step-size.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        If we reach this point and lastStep is no longer zero, then we</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        have finished the calculation. The next step (changing dh) will be</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        executed but we will leave the "while"-loop and so the new value</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        of dh will not be used.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dh *= 2.;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now prepare
        output arrays depending on what output data type has</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; been
        selected
        by the user. The arrays are only long enough to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; contain
        the number of points to the top of the atmosphere. Since</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the value
        of the variable lastStep is the step where the pressure</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first went
        negative, if we create arrays of length lastStep then</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this value
        will be excluded, since such arrays start at index 0</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and finish
        at index lastStep-1. We attach to each output Curve</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a title
        (which will appear on the graph legend), and we attach</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to the first
        output Curve the axis labels.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] finalH = new
    double[lastStep];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Curve outData =&nbsp;
        null;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String unitLabel = "";</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
    (outputType.equals("Pressure"))
    {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        double[] finalP = new double[lastStep];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        for ( j = 0; j &lt; lastStep; j++ ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalH[j] = alt[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalP[j] = p[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData =&nbsp; new Curve( finalH, finalP );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        unitLabel = " (Pa)";</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
        (outputType.equals("Density"))
        {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        double[] finalRho = new double[lastStep];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        for ( j = 0; j &lt; lastStep; j++ ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalH[j] = alt[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalRho[j] = rho[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData = new Curve( finalH, finalRho );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        unitLabel = " (kg/m^3)";</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
        (outputType.equals("Temperature"))
        {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        double[] finalT = new double[lastStep];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        for ( j = 0; j &lt; lastStep; j++ ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalH[j] = alt[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        finalT[j] = Temp[j];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData = new Curve( finalH, finalT );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        unitLabel = " (K)";</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData.setTitle(outputType
        + " for the atmosphere of " + planetName);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData.setIndependentLabels(0,"altitude
        (m)");</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        outData.setDependentLabels(0,outputType
        + unitLabel);</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output( outData );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    &nbsp;
</p>

<h3>Program getTemp for interpolating the temperature data</h3>

<p><br>
    <tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Method to compute the temperature
        at any height from the given</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; measurements at specific altitudes.
        There are three cases:</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1) The height is below the first
        measured altitude. In this</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case we
        simply use the temperature at the first measured</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; altitude,
        i.e. we take the temperature to be constant from</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the ground
        up to the first measured value.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2) The height is between two
        measured
        altitudes. This is the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normal case
        over most of the atmosphere. We find the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temperature
        between two measurements by linear interpolation,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which means
        that we draw a straight line on a graph of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temperature
        versus altitude between the two measurements,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and we use
        the temperature on the line at the actual</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; required
        height.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3) The height is above the highest
        measured altitude. Here</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; we cannot
        make the simple constant-temperature assumption</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of case
        (1), since an isothermal atmosphere goes on</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forever.
        Instead, we assume a temperature law of the form</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T =
        beta*pressure^(power),
        where beta and power are</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constants.
        We set the value of power = 0.5 in the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        initialization
        part of the code at the very beginning,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; but we do
        not know ahead of time what value of beta to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use. This
        is determined by insisting that the temperature</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; law join
        continuously onto the straight line between the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last two
        measured points, and to do that we need to know</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the pressure
        at the height of the last measurement. We</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; only know
        this as we are moving through the calculation,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; so the value
        of beta can only be computed at the step</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where we
        first reach the highest measured point. To keep</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; track of
        when this happens, we use the boolean variable</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reachedTop,
        which is false at first. If the height is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; greater
        than or equal to that of the highest measurement,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; we test
        the value of reachedTop. If it is false, as it</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; will be
        the first time we reach this altitude, then we</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compute
        beta from the local value of the pressure, and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; we then
        set reachedTop equal to true. This ensures that</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the next
        and subsequent times we reach past the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; altitude
        of the highest measurement, we will not</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; re-compute
        beta. In both cases we then compute the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temperature
        from our pressure law.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double getTemp( double height, double
        pressure ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( height &lt;= h[0]
        ) return T[0]; // return if height low</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( height &gt;=
        h[measurements
        - 1] )&nbsp; { // do if height high</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if ( !reachedTop) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        beta = T[measurements - 1] / Math.pow(pressure, power);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        reachedTop = true;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        return beta * Math.pow(pressure, power); //return when high</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j = 1; // only reach
        this step if between measured heights</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while ( height &gt; h[j]
        ) j++;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return T[j-1] + (T[j]
        - T[j-1])/(h[j] - h[j-1])*(height - h[j-1]);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    &nbsp;
    <br>
    &nbsp;
    <br>
    &nbsp;
    <br>
    &nbsp;
    <br>
    &nbsp;
</p>

<p></p>
<hr width="15%" size="4">
<br>
<b><font size="-1">Return to <a href="index.html">index</a> of all
    computer
    programs.</font></b>
</body>
</html>
