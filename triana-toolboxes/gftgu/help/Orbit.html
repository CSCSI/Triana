<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    <meta http-equiv="Content-Type"
          content="text/html; charset=iso-8859-1">
    <meta name="Generator" content="Microsoft Word 97">
    <meta name="Template"
          content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
    <meta name="GENERATOR"
          content="Mozilla/4.79 [en] (Windows NT 5.0; U) [Netscape]">
    <meta name="Author" content="Bernard F Schutz">
    <meta name="Description"
          content="Help file for Triana unit Orbit, part of the toolbox for the book Gravity from the Ground Up.This unit calculates general orbits of planets around central stars.">
    <meta name="KeyWords"
          content="Gravity from the ground up, Triana, help file">
    <title>Orbit</title>
</head>
<body text="#000000" bgcolor="#fdf5e6" link="#808080" vlink="#808080"
      alink="#ff0000" background="BH-posneg.negative.watermark.png">
<br>
<a href="license.html"><img src="HelpfileBanner.png"
                            title="Click to view license information." alt=""
                            style="border: 0px solid ; width: 375px; height: 362px;" align="right"></a>
<table cellpadding="2" cellspacing="2" border="3"
       style="text-align: left; width: 50%; margin-left: auto; margin-right: auto;">
    <tbody>
    <tr>
        <td
                style="vertical-align: top; background-color: rgb(204, 204, 204);">
            <h3
                    style="color: rgb(102, 255, 153); font-family: monospace; font-weight: bold; text-align: center;">
                <big><big><big><big><span
                        style="color: rgb(255, 0, 0);">Orbit</span></big></big></big></big></h3>

            <div style="text-align: center;"><big><font size="+2"><big><span
                    style="color: rgb(255, 0, 0);"><small><span style="font-weight: bold;"><small><span
                    style="color: rgb(0, 0, 0);">version 1.0<br>
      </span></small></span></small></span></big></font><big><big><span
                    lang="EN-GB"
                    style="font-size: 12pt; font-family: &quot;Times New Roman&quot;; font-weight: bold;">&copy;
                2003 Bernard Schutz</span></big></big></big><br>
            </div>
            <h3
                    style="font-family: helvetica,arial,sans-serif; text-align: center;">
                <large><b><span
                        style="color: rgb(0, 0, 0);">Compute the orbit of a planet around a
star in Newton's theory of gravity. The user can choose the mass of the
central star and any desired starting position and velocity for the
planet. The program can output the orbit, the velocity information, the
position or velocity as a function of time, or the kinetic and
potential energies as functions of time. The program introduces
automatic time-step adjustment and the predictor-corrector technique,
both of which improve accuracy.<br>
      </span></b></large>
            </h3>
        </td>
    </tr>
    </tbody>
</table>
<h2><a name="contents"></a>Contents</h2>
<ul>
    <li><a href="#description">Description of <tt><font size="+1">Orbit</font></tt></a></li>
    <li><a href="#using">Using <tt><font size="+1">Orbit</font></tt></a></li>
    <li><a href="#playing">Suggestions for playing with<tt><font
            size="+1">
        Orbit</font></tt></a></li>
    <li><a href="#understanding">Understanding <tt><font size="+1">Orbit</font></tt></a></li>
    <li><a href="#suggestions">Suggested modifications of <tt><font
            size="+1">Orbit</font></tt></a></li>
    <li><a href="#listing">Listing of the Java code for <tt><font
            size="+1">Orbit</font></tt></a></li>
</ul>
<hr width="15%" size="4">
<h2><a name="description"></a>Description of <tt><font size="+3">Orbit</font></tt></h2>
The unit called <tt><font size="+1">Orbit</font></tt> implements the
Java
program for computing the orbit of a planet or satellite about a
central
mass. It allows us to demonstrate that bound orbits are closed
ellipses,
something that would require advanced calculus if we restricted
ourselves
to pen-and-paper calculations. The program also&nbsp; allows the user
to
make several choices, so that the output can give different views of a
system or represent many different physical systems. This allows us to
test Newton's theory of gravity by simulating the orbits of all the
planets
and comparing the resulting shapes and periods with observed data.
<p>The user can choose the mass of the central object, the starting
    position
    and velocity of the satellite, the basic time-step for advancing the
    orbit
    step-by-step, and the maximum number of time-steps. If the orbit is
    bound,
    the program will end after it computes a single orbit, provided the
    maximum
    number of steps has not been reached. If the orbit is not bound, so
    that
    the satellite flies away, then the program will end only after the
    maximum
    number of steps has been reached. The mathematics for this is
    essentially
    the same as for the program <tt><font size="+1"><a
            href="EarthOrbit.html">EarthOrbit</a></font></tt>,
    and is described in Investigation 4.1.
</p>

<p>In addition the user can choose two numbers that regulate the
    accuracy
    of the calculation. They are used by two new numerical techniques that
    are introduced in this program: an <i>adjustable time-step</i>, and
    the
    so-called <i>predictor-corrector</i> iteration for improving the
    accuracy
    of each time-step. (Users can control these accuracy-improving
    techniques
    without having to know the details of how they are implemented. Users
    who
    want to know the details will find them described in Investigation 4.2
    and <a href="#understanding">below</a>.) Finally, the user can choose
    several
    kinds of data to output, so that detailed investigations of the results
    are possible. For example, by outputting the position as a function of
    time, the user can find out the period of the orbit. The user can also
    output measures of energy, to verify the law of conservation of energy,
    as described in Chapter 6.
</p>

<p>Users can experiment with the accuracy and the initial conditions to
    verify the theorem that bound orbits are ellipses, while unbound orbits
    are hyperbolas. They can also choose initial conditions to simulate
    different
    kinds of systems. The initial data provided by default with the program
    simulates the orbital motion of Mercury around the Sun. By changing the
    data, users could look at the Moon going around the Earth, or comets
    around
    the Sun.
</p>

<p><tt><font size="+1">Orbit</font></tt> is the foundation program for
    all
    of our later explorations of motion in this book. The programs that
    solve
    for the motion of two stars in a binary system, that examine the
    three-body
    problem and show how stars are expelled from such systems, that
    calculate
    orbits around black holes, and that study the expansion of the Universe
    after the Big Bang are all relatively straightforward modifications of
    <tt><font size="+1">Orbit</font></tt>.
    If you master this program you will open the door to learning about a
    huge
    variety of physical systems.
</p>

<p></p>
<hr width="15%" size="4">
<h2><a name="using"></a>Using <tt><font size="+3">Orbit</font></tt></h2>
Simply drag the <tt><font size="+1">Orbit</font></tt> icon from the
toolbox
into the working area, drag the <tt><font size="+1">SGTGrapher</font></tt>
unit into the area, and connect the two if Triana has not already done
so. If you press the <tt><font size="+1">Start</font></tt> button then
the
program will execute with its default settings, producing a simulation
of the orbital motion of Mercury around the Sun that is sufficiently
accurate
to see that the orbit is a closed ellipse when the data are displayed
by
the graph window that pops up automatically.
<p>Initially the graph window will adjust its scales to the orbit of
    Mercury. To get a plot that shows the orbit correctly, go to the "Plot"
    menu of
    the <tt><font size="+1">SGTGrapher </font></tt>display, and select
    "force equal ranges on both axes",
    then press "Reset Zoom".&nbsp; This ensures that the <span
            style="font-style: italic;">x</span>- and <span
            style="font-style: italic;">y</span>-
    axes are scaled in the same way. Optionally, if you find the axis
    labels difficult to read, you can select "take out common factors of 10
    from data" for a less cluttered display. You will have to re-run the
    computation to get the display to change. If you choose output options
    (below) that don't require the scales to be the same, then un-select
    this option in the "Plot" menu.
</p>

<p><img src="image67H.JPG" height="325" width="636" align="left">You
    can change
    ten parameters by opening the parameter window: double-click on the
    unit's
    icon when it is in the working area to get a window like the one shown
    to the left. The orbit parameters have default values for Mercury's
    orbit
    around the Sun. The first two lines set the x- and y-positions of the
    starting
    point, in meters from the location of the central mass. The third and
    fourth
    lines give the components of the initial velocity of the body, in ms<sup>-1</sup>.
    The fifth line is the mass of the central body in kg (default is the
    mass
    of the Sun). The sixth line gives the initial time-step. The value of
    this
    is not critical, since it will be reduced if accuracy requires it. But
    don't set it too small, since it won't be increased by the program, and
    if it is too small you will have to wait for a long time for the
    answer.
    The seventh line gives the maximum number of time-steps in the
    calculation.
    This will stop the calculation if the orbit is not closed or if this
    number
    of steps is reached before it closes. You should experiment with
    changes
    in this. The eighth line gives the error allowed for the time-step
    reduction.
    If the fractional change in a component of the acceleration has this
    size,
    then the time-step will be reduced. The default value, 0.05, is fairly
    large. You should experiment with reducing it. The ninth line sets the
    allowed error for the predictor-corrector, which ensures that the
    change
    in the acceleration over the time-step is calculated accurately. Again
    you should experiment with changes in this.
</p>

<p><img src="image9Q0.JPG" border="0" height="97" width="201"
        align="right">The
    final line is a choice box which allows you to choose the kind of
    information
    that will be output. This is a more advanced option and is designed,
    among
    other things, to help you in later chapters in the book. When the
    program
    is first introduced, in Chapter 4, you will only really need the
    default
    output option, but in Chapter 6 you will need more. The list of choices
    is shown here.
</p>
<ul>
    <li>The first choice, the default, is to output the orbit. This is a
        data
        set
        that, when graphed, will show the x-y plane of the orbit and a curve
        showing
        where the planet has gone. It does not include information about the
        time
        it takes to move from one place to another.
    </li>
    <li>The second option, "velocity space...", shows a graph of the two
        components
        of velocity, V (the x-velocity) and U (the y-velocity), and a curve
        tracing
        the values of the velocity that the planet had in its orbit. This graph
        shows no time or position information.
    </li>
    <li>To get information about how things change with time, select the
        third
        option ("position vs time ...") or the fourth ("velocity vs time ...").
        These output two data sets, and to do this the Triana unit changes its
        number of output nodes so that you can route these outputs as desired.
        If you graph the data coming out of the first output node you will see
        the graph of x-position (or x-velocity) against time along the orbit.
        If
        you graph the second you will see the corresponding y-information
        against
        time. You can create two grapher units, and connect each output to its
        own grapher; this will display two separate graph windows.
        Alternatively,
        you can create a single grapher unit and give it two input nodes (hover
        the mouse near the input node and click on the little "+" sign that
        comes
        up: you will add another node); by connecting both outputs to these two
        nodes you will see both graphs on the same chart. (Be sure to un-select
        the option "force equal ranges on both axes" in the "Plot" menu, since
        in these display option there is no relation between the two axes.)<br>
    </li>
    <li>The fifth option outputs the potential energy, kinetic energy,
        and
        total
        energy as functions of time. Energy is introduced and discussed in
        Chapter
        6. The unit requires 3 output nodes to produce this data, and so when
        you
        select this option it automatically changes to do this. Again, you can
        use separate graphing windows or a single one to see the results. What
        is actually output is the energy divided by the mass of the planet,
        since
        we have not had to specify the mass of the planet for any of the
        calculations
        of the orbit here.
    </li>
</ul>
<p><br>
</p>
<hr width="15%" size="4">
<br>
&nbsp;
<h2><a name="playing"></a>Suggestions for playing with <tt><font
        size="+3">Orbit</font></tt></h2>
The parameter window allows you a lot of choice about how to start up
the
orbit. You can vary the data there to create different kinds of orbits
and you can choose different kinds of output to look at different
information
about the orbits. Here are some suggestions.
<ol>
    <li><b>Planetary orbits</b>. The initial data that the program
        starts
        with
        duplicates the orbit of Mercury. The information in Table 4.3 in the
        book
        is enough to help you construct the orbits of the other planets. Just
        start
        them off, as with Mercury, at a distance along the x-axis given by
        their
        perihelion distance (second column of the table), and give them a
        velocity
        directed only in the y-direction equal to their maximum speed (third
        column).
        Then, from the geometry of the output orbit, try to calculate the
        eccentricity
        and compare it with the values given in the first column of the table,
        using the formula for eccentricity given in the caption for the table.
        Each of these comparisons is a test of the validity of Newton's law of
        gravitation: a different law of gravity would not be expected to give
        the
        same orbital shape as Newton's law for the same initial conditions.
    </li>
    <li><b>Planetary orbital periods</b>. For the planetary orbits you
        computed
        in the previous suggestion, you can also get an estimate of the period
        of the orbit if you choose to output "position vs time" or "velocity vs
        time" in the choice box that is the last option in the parameter
        window.
        The horizontal axis of the plots will be time along the orbit, and the
        period is the time elapsed from the beginning to the end. You can
        compare
        this with the planetary periods given in Table 4.2 of the book. Again,
        each comparison is a test of the validity of Newton's law of gravity.
    </li>
    <li><b>Orbits are periodic in velocity, too</b>. You can see from
        the
        output
        of the first run of the program that the orbit of a planet is closed.
        But
        for the planet to repeat the same orbit over and over again requires in
        addition that the velocity of the planet at the end of one orbit should
        be the same as its starting velocity. Otherwise it will go off on a
        different
        path even if it returns to the same point. To see that the velocity
        also
        repeats, select the output option "velocity space" from the output
        choice
        box. This will plot, on axes v and u (the x- and y-components of the
        velocity),
        the values of the velocity as the planet goes around its orbit. This
        curve
        is closed, just like the orbit is closed. This demonstrates the the
        next
        orbit will again follow exactly the same path as the first. If you
        limit
        the number of steps in the calculation so that it does not perform a
        full
        orbit (by decreasing the number in the option in the parameter window
        for
        the maximum number of steps), then you can see where the orbit starts
        out
        and also see that this is the place where the speed is highest.
    </li>
    <li><b>Unbound orbits</b>.The initial data that the program starts
        with
        generates
        a <i>bound</i> orbit, that is an orbit that remains within a finite
        distance
        of the central mass. You should experiment by changing the initial
        speed
        or starting point to achieve an <i>unbound</i> orbit, one that simply
        moves
        further and further away. Such an orbit describes a <i>hyperbola</i>.
        By
        performing many experiments you may be able to find the approximate
        speed
        of the marginal case, which describes a parabola.&nbsp; Comets move on
        orbits that are nearly parabolic. You can also experiment with the
        initial
        conditions to verify another remarkable fact: whether an orbit is bound
        or not depends only on two things, its starting distance from the
        central
        mass and its starting speed, but not on the <i>direction</i> of the
        initial
        speed. The orbital shape changes if you change the direction without
        changing
        the speed, but whether it is bound or not is independent of the
        direction.
        Experiment by changing the components of the initial velocity while
        keeping
        the sum of their squares the same.
    </li>
    <li><b>Energy conservation. </b>The property we have just
        described,
        that the
        boundedness of an orbit is independent of the direction of the initial
        velocity, is closely related to the fact that the total energy of a
        body
        is constant along the orbit. The energy of a body in a gravitational
        field
        is defined in Chapter 6. Once you have read that chapter, you should
        run
        some of the simulations you ran before, only this time output "energy
        vs
        time". This gives you three curves, consisting of the kinetic,
        potential,
        and total energy. The total energy (the sum of the other two) should be
        constant in time. This is the law of conservation of energy for an
        orbit
        around a central mass. Now compare the total energy of a bound orbit
        with
        that of an unbound orbit. You will see that the bound orbit has a
        negative
        total energy and the unbound a positive. This is a general rule: bound
        orbits have negative total energy. The marginal, parabolic orbit has
        zero
        total energy. Since the energy does not depend on the direction of the
        velocity, this re-inforces the observation in the previous suggested
        experiment
        about directions of velocity.
    </li>
</ol>
<p><br>
</p>
<hr width="15%" size="4">
<h2><a name="understanding"></a>Understanding <tt><font size="+3">Orbit</font></tt></h2>
The <font size="+1"><tt>Orbit</tt> </font>program allows you to solve
Newton's
laws for the motion of planets in the gravitational field of a central
mass. It goes beyond the program <tt><font size="+1"><a
        href="EarthOrbit.html">EarthOrbit</a></font></tt>
by using Newton's law of gravitation, allowing the gravitational force
to depend on the radial distance r as 1/r<sup>2</sup>. It also
introduces
two new computational techniques, an adjustable time-step and the
predictor-corrector
method. Finally, it uses angular computations to find out if the orbit
has closed, i.e. if the planet has gone once around the central mass.
We
examine each of these new features in turn.
<ol>
<li><b>Newton's law of gravitation</b>. The acceleration of gravity
    of
    a planet,
    due to the gravitational field of a body of mass M located at the
    origin
    of the coordinate system, is -GM/r<sup>2</sup>, where r is the radial
    distance
    from the origin to the planet and G is Newton's gravitational constant.
    The program introduces the constant <tt><font size="+1">k</font></tt>
    for
    the product GM, so that the acceleration is -k/r<sup>2</sup>. This
    replaces
    the constant acceleration of gravity <tt><font size="+1">g</font></tt>
    used
    in EarthOrbit, so that EarthOrbit's x-acceleration -gx/r is replaced by
    -kx/r<sup>3</sup>, and similarly for y. The mathematics is described in
    Investigation 4.1.
</li>
<li><b>Changing the time-step</b>. We have shown in the book that
    the
    results
    of the computer program can be made as accurate as one wants by
    choosing
    a small enough time-step. The key point is that our method would be
    exact
    if the acceleration did not change during the time-step, but because
    the
    position of the planet changes, there is an inevitable change in the
    acceleration.
    But if the change in position is sufficiently small, the error we make
    by assuming a constant acceleration can be made as small as we wish.
    The
    problem with this is that computer calculations take time, so
    shortening
    the time-step by too much would make a calculation very expensive of
    computer
    resources and your own time! Therefore here we take a middle road: we
    start
    with a fairly long time-step but allow the program to decide if it is
    too
    large at any particular step around the orbit; if so, the program
    starts
    the current step again with the time-step cut in half, and checks again
    to see if it is still too large. This can go on repeatedly until the
    time-step
    is small enough to guarantee sufficient accuracy. The program defines a
    variable <tt><font size="+1">dt0</font></tt> that holds the initial
    time-step
    given by the user, but it actually uses a variable <tt><font size="+1">dt1</font></tt>
    as the time-step during the computation. It sets <tt><font size="+1">dt1
        = dt0</font></tt> at the beginning and then reduces <tt><font size="+1">dt1</font></tt>
    if necessary.
</li>
<p><br>
    The computer must be told, of course, what accuracy you want. The
    program's parameter window allows you to tell it the accuracy limit by
    giving a dimensionless number which is a measure of the <i>relative
        error</i>
    you can tolerate in assuming a constant acceleration. This number is
    stored
    in the variable <tt><font size="+1">eps1</font></tt>. The relative
    error
    is just the fractional change in the acceleration during the time-step.
    Of course, until we calculate the orbit accurately, we won't know where
    the planet is at the end of the time-step, so we can't exactly
    calculate
    the acceleration at that time. But we can get a fairly good idea of its
    size by just pretending the planet moves according to a constant
    acceleration
    given by the acceleration at the beginning of the current time-step.
    These
    acceleration components are called <tt><font size="+1">ax0</font></tt>
    and <tt><font size="+1">ay0</font></tt>
    in the program. </p>

<p>If the acceleration a<sub>x</sub> is constant, then the x-velocity
    of
    the planet changes in a time <font face="SymbolPS">D</font>t by the
    amount <font face="SymbolPS">D</font>v
    = a<sub>x</sub> <font face="SymbolPS">D</font>t. This is stored in the
    variable <tt><font size="+1">dv</font></tt>. The x-position changes
    with
    a velocity that is the average of the beginning x-velocity v and the
    ending
    x-velocity v + <font face="SymbolPS">D</font>v. This average is v + <font
            face="SymbolPS">D</font>v/2,
    so the change in position is <br>
    <font face="SymbolPS">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        D</font>x = v<font face="SymbolPS">D</font>t + (<font face="SymbolPS">D</font>v/2)<font
            face="SymbolPS">D</font>t. <br>
    The program defines two new variables to hold the values of the two
    terms in this expression: <tt><font size="+1">dx</font></tt> holds v<font
            face="SymbolPS">D</font>t
    (computed as <tt><font size="+1">v*dt1</font></tt>) and <tt><font
            size="+1">ddx0</font></tt>
    holds (<font face="SymbolPS">D</font>v/2)<font face="SymbolPS">D</font>t
    (computed as <tt><font size="+1">dv/2*dt1</font></tt>). Notice that <tt><font
            size="+1">dx</font></tt>
    is independent of the acceleration, but the accuracy of <tt><font
            size="+1">ddx0</font></tt>
    depends on the accuracy of the acceleration, which affects <tt><font
            size="+1">dv</font></tt>.
    Therefore the program also defines a variable <tt><font size="+1">ddx1</font></tt>,
    which it later uses to hold an improved value of this term in the
    predictor-corrector
    step. All of this is done in the same way for y as well as x. </p>

<p>The measure of accuracy that influences the time-step is not
    particularly
    sophisticated. The change in acceleration is computed by finding the
    acceleration
    at the new position ( <tt><font size="+1">x1</font></tt>,<tt><font
            size="+1">y1</font></tt>),
    where <tt><font size="+1">x1</font></tt> holds the value of x + <font
            face="SymbolPS">D</font>x
    as above, and similarly for y. This acceleration is stored in <tt><font
            size="+1">(ax1,ay1)</font></tt>.
    The change in the x-acceleration, <tt><font size="+1">ax1-ax0</font></tt>,
    should not be too large. Nor should the change <tt><font size="+1">ay1-ay0</font></tt>.
    The program simply computes the sum of the absolute values of the
    changes, <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Math.abs(ax1-ax0)
        + Math.abs(ay1-ay0)</font></tt>, <br>
    and compares it with the sum of the absolute values of the acceleration
    components at the beginning of the time-step, <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Math.abs(ax0)
        + Math.abs(ay0)</font></tt>. <br>
    If the change is larger than the number <tt><font size="+1">eps1</font></tt>
    times the original, then the time-step is halved and the whole step is
    done again. Thus, the code has an <tt><font size="+1">if</font></tt>
    statement
    with the test <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Math.abs(ax1-ax0)+Math.abs(ay1-ay0)
        &gt; eps1*(Math.abs(ax0)+Math.abs(ay0))</font></tt> <br>
    This test is not the only test one could use, but it is important to
    remember that the test is only used to shorten the time-step; the
    values
    computed for the test are not used in the computation of the orbit of
    the
    planet. One could use the squares of the quantities instead of their
    absolute
    values, for example, and the result would not be very different. The
    important
    thing is to choose the value of <tt><font size="+1">eps1</font></tt>
    small
    enough that the test will reduce the time-step before errors begin to
    creep
    into the calculation. </p>

<p>If you want to see what happens without a time-step correction,
    you
    don't need to change the program. Just set <tt><font size="+1">eps1</font></tt>
    to some large value, like 10. Then the test will never be satisfied and
    the time-step will never be changed. </p>
<li><b>Predictor-corrrector</b>. We could rely on smaller and smaller
    time-steps
    to get better accuracy, but there are other ways to improve the
    accuracy
    of a given time-step, and they are often more efficient, in that they
    give
    an accurate result in a shorter time. One such technique is the
    predictor-corrector
    method. It is a powerful concept, which can be used in a wide variety
    of
    situations. We introduce it here because the problem of planetary
    motion
    allows us to illustrate the method in a simple way. See Investigation
    4.2
    for an introduction.
</li>
<p><br>
    The predictor-corrector method addresses the problem we mentioned
    above, that the acceleration at the end of a time-step must be known so
    that we can accurately calculate the change in velocity and from the
    that
    change in position, but the acceleration can't be known until we know
    what
    the change in the position is, since the acceleration depends on
    position.
    This is a kind of chicken-and-egg problem, and the predictor-corrector
    method is perfect for solving it. The idea is to find a series of
    successively
    more accurate approximations to the final position. The method performs
    an <i>iteration</i>, which is the mathematical word to describe doing
    the
    same thing over and over again. Under normal circumstances, this
    iteration
    should produce a result that converges to the correct position. </p>

<p>Note that all we want to improve is our value for what we call ddx
    =
    (<font face="SymbolPS">D</font>v/2)<font face="SymbolPS">D</font>t and
    ddy=(<font face="SymbolPS">D</font>u/2)<font face="SymbolPS">D</font>t.
    We start out with our first approximation, which is the one we used
    above
    to find <tt><font size="+1">(x1,y1)</font></tt> using the acceleration
    at
    the beginning of the time-step to find <font face="SymbolPS">D</font>v.
    Having found our approximation to the new position, we then use this to
    find the acceleration at the end of the time-step, which is stored in <tt><font
            size="+1">(ax1,ay1)</font></tt>,
    as described above. Now we are ready to start the iteration. </p>

<p>First we use the beginning and ending accelerations to compute a
    better
    value for the change in speed (<font face="SymbolPS">D</font>v,<font
            face="SymbolPS">D</font>u)
    by averaging the acceleration. For example, the program contains the
    following
    statement for the x-velocity change: <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dv =
        (ax0
        + ax1)/2*dt1;</font></tt> <br>
    The next step is to compute a better value for ddx, which we store
    in the variable <tt><font size="+1">ddx1</font></tt>: <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ddx1 =
        dv/2*dt1;</font></tt> <br>
    This and the better value of ddy stored in ddy1 are tested to see if
    they are very different from the values held in ddx0 and ddy0. If they
    are then the iteration repeats. If not, then we assume that we have
    converged
    well enough on the right value of the position and the iteration stops.
    Each of these steps -- the test, the repeat, the exit -- needs to be
    discussed
    a little. </p>

<p>The test is similar to the test we used for the time-step
    adjustment.
    There is an <tt><font size="+1">if</font></tt> statement with the test
    <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Math.abs(ddx1-ddx0)
        + Math.abs(ddy1-ddy0) &gt; eps2 * testPrediction</font></tt> <br>
    where the value of testPrediction was computed just before the
    predictor-corrector
    iteration: <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        testPrediction
        = Math.abs(ddx0) + Math.abs(ddy0);</font></tt> <br>
    This holds the original size of ddx. The test above says that if the
    change in the estimate of ddx is larger than the small number <tt><font
            size="+1">eps2</font></tt>
    times the original, then the iteration will continue. It will stop only
    if the change in the estimated value of ddx during the last iteration
    is
    sufficiently small. </p>

<p>If the iteration repeats, then the program stores the most
    recently
    computed values of <tt><font size="+1">ddx1</font></tt> and <tt><font
            size="+1">ddy1</font></tt>
    into the variables <tt><font size="+1">ddx0</font></tt> and <tt><font
            size="+1">ddy0</font></tt>.
    That ensures that when the test is applied again, after new values of <tt><font
            size="+1">ddx1</font></tt>
    and <tt><font size="+1">ddy1</font></tt> have been computed, the
    changes
    that are used in the test, like <tt><font size="+1">ddx1-ddx0</font></tt>,
    are indeed the changes in the most recently computed approximations to
    ddx. To complete the preparations for the next iteration, the position
    is updated and the acceleration at the new position is computed. </p>

<p>To exit from the iteration, we just use the <tt><font size="+1">break</font></tt>
    statement, which ensures that the next statement to be executed is the
    one following the loop. This one uses the previously computed values of
    ddx and ddy (since they are now known to be good enough) to move the
    planet
    to the beginning of the next time-step, finds the acceleration there,
    and
    stores the resulting position in the arrays used to keep position
    information.
    Then, if the orbit has not yet closed, the computer goes on to the next
    time-step. </p>

<p>Notice that we have coded the predictor-corrector with a <tt><font
        size="+1">for</font></tt>
    loop that has 10 steps (with index <tt><font size="+1">k</font></tt>
    counting
    the steps). Even if the predictor-corrector has not converged, we exit
    the loop after 10 iterations. This is a safety measure: if the program
    has not converged by 10 steps, it may well never converge. We don't
    want
    the program to loop around forever waiting for convergence. </p>

<p>As for the time-step changer, f you want to see what happens
    without
    the predictor-corrector, you don't need to change the program. Just set
    <tt><font size="+1">eps2</font></tt>
    to some large value, like 10. Then the test will never be satisfied and
    the predictor-corrector iteration will not take place. </p>

<p>It is important to understand what the predictor-corrector does
    and
    does not accomplish. Its only purpose is to get the best possible value
    for the position at the end of the time-step, within the
    finite-difference
    approximation, i.e. within the approximation that the position advances
    by the average velocity during the time-step and the velocity changes
    by
    the average acceleration. The predictor-corrector does not do better
    than
    this approximation, and so if the acceleration were constant the
    predictor-corrector
    would not improve things further. If the time-step is too large, for
    example,
    the predictor-corrector will not cure that problem. Therefore, the two
    kinds of accuracy improvements that we have implemented in this program
    are complementary; they act at different places in the calculation. </p>
<li><b>Closed orbit</b>.&nbsp; One of the most remarkable things
    about orbits
    in Newtonian gravity is that planetary orbits close, which means that
    when
    the planet has gone exactly once around the central mass, it returns to
    the same radial distance and has the same velocity as when it started.
    This ensures that the orbit goes over and over again on the same path,
    even if it is an elliptical orbit. We therefore stop the orbit
    calculation
    when the orbit has gone around once, provided it has not already been
    stopped
    because it exceeded the maximum allowed number of time-steps chosen by
    the user. Notice that, since the time-step can be reduced, one cannot
    be
    sure how many time-steps will be required to go once around. So the
    test
    for completing the orbit is a more sensible one.
</li>
<p><br>
    It is surprisingly complex to decide when the orbit has gone around
    once. Since the intial position and velocity can be freely chosen by
    the
    user, we must cope with orbits that go clockwise or counter-clockwise,
    and with orbits that start on the x-axis, the y-axis, or within any
    quadrant.
    The way we implement the test in this program is to compute the angular
    position of the starting point, then monitor the angular position of
    the
    orbit at every subsequent time-step, and stop the calculation when the
    orbit comes back to the starting angle. Each of these simple ideas
    needs
    to be implemented carefully. </p>

<p>Computing an angle is itself not a trivial matter, because angles
    are
    not uniquely defined. If an angle has a value <font face="SymbolPS">a</font>,
    then the same angle could be represented by <font face="SymbolPS">a</font>+2<font
            face="SymbolPS">p</font>
    or by <font face="SymbolPS">a-</font>2<font face="SymbolPS">p</font>.
    Mathematical
    functions that compute angles have to return a unique value, which
    might
    be 2<font face="SymbolPS">p</font> or 4<font face="SymbolPS">p</font>
    away
    from the value we want to compare it with. So we must always be careful
    about this ambiguity. The best way to compute the angle in Java is to
    use
    the function <tt><font size="+1"><a href="Introduction.html#functions">Math.atan2</a></font></tt>,
    which takes two arguments, say a and b, and returns the polar angle of
    the point (b,a) in the x-y plane, i.e. the angle between the x-axis and
    the radial line from the origin to the point (b,a). (Be careful about
    the
    order of the arguments in the function: the y-argument comes first!) By
    convention, this value is between -<font face="SymbolPS">p</font> and +<font
            face="SymbolPS">p</font>. </p>

<p>Now, in the program we compute the intial angular position and
    assign
    it to the variable angleInitPos: <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
        angleInitPos = Math.atan2(yInit, xInit);</font></tt> <br>
    The arguments are the variables that hold the initial location of the
    planet, with the y-position first as noted above. Suppose, for
    simplicity,
    that the orbit starts in the first quadrant, or on the x-axis, and
    moves
    counter-clockwise, i.e. in the direction of increasing angular
    position.
    At each time-step we calculate the current angular position, which is
    held
    in the variable <tt><font size="+1">angleNow</font></tt>. What is the
    difference
    in the angles? At first, the difference will be simply <tt><font
            size="+1">angleNow-angleInitPos</font></tt>,
    but at some point the orbit will go into the third quadrant and the
    value
    of <tt><font size="+1">angleNow</font></tt> will be somewhere between -<font
            face="SymbolPS">p </font>and
    0. Taking the difference <tt><font size="+1">angleNow-angleInitPos</font></tt>
    will now not give the right angular difference. Instead, we will have
    to
    add 2<font face="SymbolPS">p</font> to <tt><font size="+1">angleNow</font></tt>&nbsp;
    to get the "right" angular position now. The way we cope with this
    problem
    in the present program is to ensure that the angular difference in the
    orbit is itself confined in the range between -<font face="SymbolPS">p</font>
    and +<font face="SymbolPS">p.</font> We test it to see if it goes
    outside
    this range, and if it does we add or subtract 2<font face="SymbolPS">p</font>
    as necessary to restore it to this range. </p>

<p>It is then a relatively simple matter to decide if the orbit has
    returned
    to the beginning. If the orbit is counter-clockwise, we just look for
    the
    point where this angular difference becomes positive again: as the
    orbit
    approaches its starting point, it does so from negative angular
    differences.
    If the orbit is clockwise, we look for the angular difference to become
    negative again. </p>

<p>The word "again" hides a further complication we need to consider:
    of
    course, at the very beginning the angular difference was also positive
    for counter-clockwise orbits and negative for clockwise ones. We don't
    want the program to stop after the first time-step, so we must prevent
    it from applying the test for closure until after the orbit has gone
    more
    than half-way around. The half-way point is exactly where the sign of
    the
    angular difference changes (for clockwise orbits, the angular
    difference
    is positive at first but becomes negative -- because we subtract 2<font
            face="SymbolPS">p</font>
    -- after the half-way point). </p>

<p>Finally, how do we know if the orbit is clockwise or
    counter-clockwise?
    We check for that in the very beginning by looking at the initial
    velocity
    of the planet as well as its position. If the velocity vector makes an
    angle that is positive with respect to the position angle, then the
    orbit
    will move off in the positive direction, and the orbit will be
    counter-clockwise. </p>

<p>The program uses several boolean variables to keep track of the
    conditions
    that we have just met. It defines <tt><font size="+1">counterclockwise</font></tt>,
    which is <tt><font size="+1">true</font></tt> if the orbit is
    counter-clockwise
    and <tt><font size="+1">false</font></tt> otherwise. It defines <tt><font
            size="+1">halfOrbit</font></tt>
    to keep track if the orbit has gone half-way; this starts out with the
    value <tt><font size="+1">false</font></tt> and is set to <tt><font
            size="+1">true</font></tt>
    when the test for completing half an orbit, mentioned above, is
    satisfied.
    This test, of course, depends on the value of <tt><font size="+1">counterclockwise</font></tt>.
    And the test can only be applied if the orbit has not yet gone
    half-way.
    Therefore the program contains the following code near the end of each
    time-step: <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if (!halfOrbit) {</font></tt> <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if (counterclockwise) halfOrbit = (anglediff &lt; 0);</font></tt> <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else halfOrbit = (anglediff &gt; 0);</font></tt> <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</font></tt> <br>
    This is executed only if we are not yet halfway. When it is executed,
    then for a counterclockwise orbit the value of <tt><font size="+1">halfOrbit</font></tt>
    is set to the value of the boolean expression <tt><font size="+1">(anglediff
        &lt; 0)</font></tt>. This expression uses the conditional operator &lt;
    (less-than). If <tt><font size="+1">anglediff</font></tt> is less than
    0
    then it evaluates to <tt><font size="+1">true</font></tt> and the
    statement
    then sets the value of <tt><font size="+1">halfOrbit</font></tt> to <tt><font
            size="+1">true</font></tt>.
    For clockwise orbits the third line above is executed, changing <tt><font
            size="+1">halfOrbit</font></tt>
    to <tt><font size="+1">true</font></tt> if the angular difference has
    become
    positive. </p>

<p>The third boolean is <tt><font size="+1">fullOrbit</font></tt>,
    which
    is <tt><font size="+1">false</font></tt> at first and is set to <tt><font
            size="+1">true</font></tt>
    when we pass the test for a full orbit. This test is implemented as the
    <tt><font size="+1">else</font></tt>
    clause of the if statement given just above, which ensures that we only
    test for a full orbit if we have already gone halfway around: <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else {</font></tt> <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if ( counterclockwise ) fullOrbit = (anglediff &gt; 0);</font></tt> <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else fullOrbit = fullOrbit = (anglediff &lt; 0);</font></tt> <br>
    <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</font></tt> <br>
    The test has the same kind of structure as above, but now the
    conditions
    are arranged so that they test for a full orbit. Once <tt><font
            size="+1">fullOrbit</font></tt>
    is <tt><font size="+1">true</font></tt>, the loop over time-steps
    finishes. <br>
    &nbsp; </p>

<p></p>
<hr width="15%" size="4">
</ol>
<h2>
    <a name="suggestions"></a>Suggested modifications of <tt><font
        size="+3">Orbit</font></tt></h2>
The program <tt><font size="+1">Orbit</font></tt> is already longer
and more
involved than its predecessor, <tt><font size="+1">EarthOrbit</font></tt>.
Nevertheless, you may want to consider implementing some further
changes
to make it more efficient or more robust. Here are some suggestions:
<ul>
    <li>Notice that the value of <tt><font size="+1">dt1</font></tt> is
        always
        used
        for the time-step. Thus, when the time-step is cut in half, the next
        step
        uses this smaller value from the start. This is good in one way: it is
        quite likely that two successive time-steps will need to be similar in
        size for the same accuracy, since the acceleration will not change much
        from one step to the next. But in the long run this can be inefficient.
        There may be a region of the orbit where small time-steps are needed,
        but
        then later in the orbit the time-step could be made larger. This would
        happen, for example, in computing the orbit of a comet that comes very
        close to the Sun; near the Sun one might need a small time-step because
        the changes in the orbit are rapid. But before and after the time of
        closest
        approach one could do with a longer step. You should try to think of a
        test for lengthening the time-step in addition to our test for
        shortening
        it.
    </li>
    <li>The program stops if the orbit goes once around, but you may want
        explicitly
        to test how accurately the second orbit falls on the first. Change the
        test so that the orbit goes around 1.5 times, or 2 times. You may need
        to implement another boolean variable or a counter of orbits.
    </li>
    <li>Change the accuracy tests to use the sums of the squares of the
        differences,
        compared to the sums of the squares of the original values. Does this
        make
        any noticeable difference in the accuracy of the orbits you compute?
    </li>
    <li>The predictor-corrector is implemented using the loop with index <tt><font
            size="+1">k</font></tt>.
        Implement this in a different way that ensures that the
        predictor-corrector
        keeps going until it reaches its desired accuracy, even if this takes
        more
        than 10 steps. To prevent the loop going on without stopping, implement
        a test to stop it if the predictor-corrector is actually making the
        calculation <i>less</i>
        accurate!
    </li>
    <li>Change the way the program decides whether the orbit is clockwise
        or
        counter-clockwise.
        Instead of looking at the initial velocity, wait until after the first
        time-step and see in which direction the orbit has moved. Fix the value
        of the boolean variable <tt><font size="+1">counterclockwise</font></tt>
        only after this first time-step.
    </li>
    <li>Check what happens if the user gives an initial velocity that is
        directed
        exactly radially inwards. In this case, the orbit is neither clockwise
        nor counter-clockwise, and it threatens to reach the origin, where the
        acceleration will be infinite. Do some examples with suitably chosen
        initial
        data, see what goes wrong, and make changes in the program to cope
        better
        with this case.
    </li>
    <li>The next suggestion is more ambitious but very informative. You
        could
        modify
        the Newtonian law of gravity to see what the effects would be of
        different
        laws. There is a mathematical theorem that says that all orbits will be
        closed only if the central mass exerts a force on the orbiting body
        that
        depends on distance either as 1/r<sup>2</sup> or as r. The first law is
        Newton's law of gravity, and the second is Hooke's law for the spring.
        It would apply to a body connected to the central mass by a spring that
        pivots about the center with no friction.
    </li>
    <p><br>
        You could implement Hooke's law by changing the code for the
        acceleration.
        For example, before the for loop, there is at present the code <br>
        <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
            ax0 = -kGravity*x0/r3;</font></tt> <br>
        <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
            ay0 = -kGravity*y0/r3;</font></tt> <br>
        This computes the acceleration by multiplying the Newtonian law k/r<sup>2</sup>
        by the appropriate fraction x/r or y/r to get the components in the x-
        and y-directions, respectively. If we replace the Newtonian law by kr
        and
        then again multiply by the appropriate fractions, we would use the code
        <br>
        <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
            ax0 = -k*x0;</font></tt> <br>
        <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
            ay0 = -k*y0;</font></tt> <br>
        To use this you would have to define the constant <tt><font size="+1">k</font></tt>
        in a sensible way. One way is to ensure that the acceleration of
        Mercury
        has roughly the same size in both laws, ie take <tt><font size="+1">k</font></tt>
        to equal <tt><font size="+1">kGravity/r3</font></tt> when <tt><font
                size="+1">r3</font></tt>
        is the cube of the radius of Mercury's orbit. By making replacements of
        this kind throughout the code, you can see how a Hooke's law solar
        system
        would look. In particular, the orbits should again be closed, but they
        will not be ellipses. </p>

    <p>You could experiment with other force laws just for fun. For
        example,
        a 1/r3 force law would need the code <br>
        <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
            ax0 = -k*x0/r4;</font></tt> <br>
        <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
            ay0 = -k*y0/r4;</font></tt> <br>
        where <tt><font size="+1">r4</font></tt> is the fourth power of the
        radial
        distance <tt><font size="+1">r</font></tt>, and where this <tt><font
                size="+1">k</font></tt>
        would be defined so that it equals <tt><font size="+1">kGravity*r</font></tt>
        at Mercury's orbit. What kinds of orbits do you get with this law? </p>

    <p>Finally, and perhaps most interestingly, experiment with a
        modification
        of Newton's law where a small correction is added with a different
        power.
        Thus, a law with the total acceleration -kGravity/r2 - k/r4 could be
        coded
        as <br>
        <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
            ax0 = -kGravity*x0/r3*(1 + eps3/r2);</font></tt> <br>
        <tt><font size="+1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
            ay0 = -kGravity*y0/r3*(1 + eps3/r2);</font></tt> <br>
        where r2 is the square of the radius and eps3 is a number chosen so
        that the second term is small on Mercury's orbit. This could be, say,
        0.1
        times the square of the radius of Mercury's orbit. You will find that
        these
        orbits do not quite close, but instead describe elegant rosettes if
        continued
        for more than one orbit. (You will have to implement the
        above-mentioned
        suggestion that the program be allowed to output more than one orbit if
        you want to see these patterns.) Historically, various astronomers
        tried
        to find small modifications of Newton's law of gravitation when it was
        discovered that Mercury moves on an orbit that is rosette-like, and the
        amount by which an orbit does not close (called its orbital <i>precession</i>)
        was not explainable by the tidal effects of Jupiter or the other
        planets.
        In the end, Einstein explained the effect exactly by modifying Newton's
        law in a big way: he introduced general relativity. We will see in the
        program <tt><font size="+1"><a href="RelativisticOrbit.html">RelativisticOrbit</a></font></tt>
        that the effective acceleration law used by Einstein is exactly of the
        form suggested here.</p>
</ul>
If you want to change the program you will have to re-compile it, as
explained
by the help file <a href="UsingTriana.html">Using Triana for
    <i>Gravity
        from the ground up</i></a>.
<p></p>
<hr width="15%" size="4">
<h2><a name="listing"></a>Listing of the Java code for <tt><font
        size="+3">Orbit</font></tt></h2>

<h3>
    Preliminary definitions of parameters and constants</h3>

<p><br>
    <tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xInit is the initial value of the
        x-coordinate of the planet,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in meters. Similarly, yInit is the
        initial value of the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y-coordinate. These are given
        default
        values but their values for</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; any run are set by the user in the
        parameter window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double xInit;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double yInit;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vInit and uInit are the initial
        values of the x- and y-</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; velocities, respectively, in meters
        per second. These</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; are given default values but their
        values for any run</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; are set by the user in the parameter
        window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double vInit;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double uInit;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M is the mass (in kg) of the object
        creating the gravitational field</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in which the orbit is computed.
        The default value is the mass of the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sun, but it is set by the user in
        the parameter window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double M;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt is the time-step in seconds.
        It has a default value but it can</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be set by the user in the parameter
        window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double dt;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxSteps is the maximum number of
        steps in the calculation. This is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; used to ensure that the calculation
        will stop even if initial values</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; are chosen so that the projectile
        goes far away. It is given</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a default value but it can be set
        by the user in the parameter window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private int maxSteps;</tt>
    <br>
    &nbsp;
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eps1 sets the accuracy of the
        time-step.
        If computed quantities</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; change by a larger fraction than
        this in a time-step, the time-step</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; will be cut in half, repeatedly
        if necessary. Its value for any run</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is set by the user in the parameter
        window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double eps1;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eps2 sets the accuracy of the
        predictor-corrector
        step. Averaging</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; over the most recent time-step is
        iterated until it changes by</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; less than this relative amount.
        Its value for any run is set by</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the user in the parameter window.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private double eps2;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outputType regulates the data that
        is to be output from the program.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The computation produces many kinds
        of data: positions, velocities,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; energies. In order to make them
        accessible, the user can select a</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value for this String, and the unit
        will output the required data.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; First-time programmers can safely
        ignore these output issues, which</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add some length to the program,
        although in a straightforward way.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Here are the choices and the data
        that they produce:</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "orbit (X,Y)" is the default
        choice
        and produces the orbit of the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; planet drawn in the
        X-Y plane of the orbit. The unit outputs this</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data from a single
        output
        node, which should be connected to the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graphing unit.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "velocity space (V,U)" produces
        a curve in what physicists call</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; velocity space, a graph
        whose axes are the x- and y-components of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the velocity. Since
        a planet on a closed orbit also comes back to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the same velocity after
        one orbit, the graph of this curve will</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be closed for such an
        orbit. The unit outputs this data from a</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; single output node,
        which should be connected to the graphing unit.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "position vs. time (X,t) and
        (Y,t)"
        produces two curves, one giving</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the value of the
        X-coordinate
        (vertical axis of the graph) against</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the time along the orbit
        (horizontal axis) and the second giving the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y-coordinate against
        time. To produce this data the unit automatically</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; changes the number of
        its output nodes to two as soon as the user</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selects this option
        in the user interface window; the first output</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; node produces a curve
        of (X,t) and the second output node produces</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Y,t). The user should
        connect both nodes to the grapher to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; see both curves at once.
        Alternatively, if only one is connected to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the grapher then only
        that particular coordinate will be displayed.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; To connect two inputs
        to the grapher the user must use the grapher</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unit's node window to
        set the number of input nodes to two.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "velocity vs. time (V,t) and
        (U,t)"
        This does the same as the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; previous choice except
        that it produces the x- and y-components of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the velocity (V and
        U) as functions of time instead of the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; coordinate positions.
        Again the unit changes its number of output</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nodes to two, and the
        user must change the grapher's input nodes to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; two as well.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - "energy vs time" This produces
        three curves: the potential energy,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the kinetic energy,
        and the total energy, all as functions of time.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The unit changes itself
        to three output nodes and the data are output</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in the order given in
        the previous sentence. To see all three at</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; once, as in the figure
        in the text, modify the number of input nodes</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of the grapher to three
        and connect them all.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private String outputType;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This variable is for internal use
        and is not set by the user.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp; private TaskInterface task;</tt>
    <br>
    &nbsp;
    <br>
    &nbsp;
</p>

<h3>Program code</h3>

<p><br>
    <tt>&nbsp;&nbsp;&nbsp; public void process() throws Exception {</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Define and
        initialize the variables we will need. The position</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and velocity
        components are referred to an x-y coordinate system</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whose origin
        is at the central gravitating mass. We need the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; following
        variables for the calculation:</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - t is the
        time since the beginning of the orbit.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - dt1 will
        be used as the "working" value of the time-step, which can</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        be changed during the calculation. Using dt1 for the time-step allows</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        us to keep dt as the original value, as specified by the user. Thus,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dt1 is set equal to dt at the beginning of the calculation, but it may
        be</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        reduced at any time-step, if accuracy requires it.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - v and
        u are the x- and y-speed, given here their initial values.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - x0 and
        y0 are variables that hold x- and y-coordinate values.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - r is the
        distance of the point (x0, y0) from the central mass.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - r3 is
        the cube of the radial distance.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - kGravity
        is the constant GM in Newton's law of gravity, where G is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Newton's gravitational constant.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ax0 and
        ay0 are the x-acceleration and y-acceleration, respectively,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        at the location (x0, y0).</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
        xCoordinate
        and yCoordinate are used to store the values of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        x and y at each timestep. They are arrays of length maxSteps.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - xVelocity
        and yVelocity are arrays that are used to store the values</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        of the velocity components at each timestep.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
        potentialEnergy
        and kineticEnergy are arrays that are used to store</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the values of the potential and kinetic energy of the planet, taking</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        its mass to equal 1. (The mass of the planet is not needed for the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        other calculations in this program, and since both energies are</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        simply proportional to the mass, the energies for any particular</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        planetary mass can be obtained by multiplying these values by</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the mass after they are output from the program.)</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - time is
        an array that is used to store the value of the time</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        associated with the current position, as measured from the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        beginning of the orbit.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double t = 0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double dt1 = dt;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double v = vInit;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double u = uInit;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x0 = xInit;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double y0 = yInit;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double r = Math.sqrt(
        x0*x0 + y0*y0 );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double r3 = r*r*r;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double kGravity = M
        * 6.6726e-11;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double ax0 =
        -kGravity*x0/r3;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double ay0 =
        -kGravity*y0/r3;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] xCoordinate
        = new double[ maxSteps ];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] yCoordinate
        = new double[ maxSteps ];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] xVelocity =
        new double[ maxSteps ];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] yVelocity =
        new double[ maxSteps ];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] potentialEnergy
        = new double[ maxSteps ];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] kineticEnergy
        = new double[ maxSteps ];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double[] time = new
        double[ maxSteps ];</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xCoordinate[0] = x0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yCoordinate[0] = y0;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now define
        other variables that will be needed, but without giving</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initial
        values. They will be assigned values during the calculation.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - x1 and
        y1 are temporary values of x and y that are needed during the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        calculation.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ax1 and
        ay1 are likewise temporary values of the x- and y-acceleration.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - dx and
        dy are variables that hold part of the change in x and y that</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        occurs during a time-step.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - ddx0,
        ddy0, ddx1, and ddy1 are variables that hold other parts of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the changes in x and y during a time-step. The reason for having both</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dx and ddx will be explained in comments on the calculation below.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - dv and
        du are the changes in velocity that occur during a time-step.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
        testPrediction
        will hold a value that is used by the predictor-corrector</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        steps to assess how accurately the calculation is proceeding.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - angleNow
        holds the angular amount by which the planet has advanced in its</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        orbit at the current time-step.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - j and
        k are integers that will be used as loop counters.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x1, y1, ax1,
        ay1, dv, du, dx, dy, ddx0, ddy0, ddx1, ddy1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double testPrediction,
        angleNow;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int j, k;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Finally,
        we introduce some variables that are used to determine when the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trajectory
        completes a full orbit, so that the program can stop. This is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not a simple
        job, if we want to be able to handle any starting position</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and any
        starting velocity. The idea is to determine from the initial</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position
        and velocity whether the trajectory will move in the clockwise</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or
        counterclockwise
        direction around the central mass. Having established</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that, then
        we will write code below that checks to see if the angular</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; position
        of the trajectory has become larger (in the counterclockwise case)</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or smaller
        (clockwise) than the starting position. If so, then the program</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stops, since
        the original position has been passed. Of course, at the very</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start the
        orbit satisfies these conditions as well, so the test can only</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be applied
        after the orbit has gone at least half-way. The variables that</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; are needed
        in order to perform these tests are as follows:</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
        angleInitPos
        is the angle that a line from the origin to the initial</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        position makes with the x-axis. Like all the other angles, it is
        computed</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        from the initial data using the Math.atan2 function. This returns a</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        value between -Pi and +Pi radians.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
        angleInitVel
        is similarly the angle that the initial velocity vector</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        makes with the x-axis</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - anglediff
        is the angle between the position and velocity, which is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        used to decide whether the orbit will move in the clockwise or</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        counter-clockwise direction. The comments just before its definition</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        explain how we ensure that it is in the same range (-Pi, Pi) as the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        other angles.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
        counterclockwise
        is a boolean variable (true/false) which is true if</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the orbit moves in the counterclockwise direction, false otherwise</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - fullOrbit
        ia another boolean variable that will be set to true when</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the orbit returns to its starting point, so that the calculation can</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        stop. Its initial value is set to false.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - halfOrbit
        is a boolean variable that begins with the value false, and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        will be set to true when the orbit has gone half-way around.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double angleInitPos
        = Math.atan2(yInit, xInit);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double angleInitVel
        = Math.atan2(uInit, vInit);</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Since the
        two initial angles will both be in the range (-Pi, Pi), their</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; difference
        anglediff can be anywhere between (-2*Pi, 2*Pi). In order to</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; put
        anglediff
        into the same range as the other angles, one can add or</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subtract
        2*Pi to it without changing the actual location of the angle. So</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if the angle
        is larger than Pi, subtract 2*Pi to set it between Pi and -Pi;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; similarly
        if it is smaller than -Pi, add 2*Pi to set it between Pi and -Pi.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double anglediff =
        angleInitVel
        - angleInitPos;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( anglediff &gt;
        Math.PI
        ) anglediff -= 2*Math.PI;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (anglediff &lt;
        -Math.PI) anglediff += 2*Math.PI;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean counterclockwise
        = ( anglediff &gt; 0 );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean fullOrbit =
        false;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean halfOrbit =
        false;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now start
        the loop that computes the trajectory. The loop counter</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is j, which
        (as in EarthOrbit) starts at 1 and increases by 1 each</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; step. The
        test for exiting from the loop will be either that the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; orbit has
        gone once around, or that the number of steps exceeds</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the maximum
        set by the user. This latter test is important because</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some orbits
        do not close: if the initial velocity is too large the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trajectory
        simply goes off to larger and larger distances. The</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logical
        expression that provides the test is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        !fullOrbit &amp;&amp; ( j &lt; maxSteps )</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Note the
        use of the logical negation operator !: !fullOrbit is true</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; when
        fullOrbit
        is false, i.e. before the end of the orbit, so it</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allows the
        loop to continue.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( j = 1; (
        !fullOrbit
        &amp;&amp; ( j &lt; maxSteps )); j++ ) {</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        - Set dv and du to the changes in x- and y-speeds that would occur</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        during time dt1 if the acceleration were constant at (ax0, ay0).</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        - Similarly set dx and dy to the changes in position that would</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        occur if the velocity components v and u were constant during the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        time dt1.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        - Set ddx0 and ddy0 to the extra changes in x and y that occur because</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the velocity changes during the time dt1. The velocity change that</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        is used is only dv/2 (or du/2, respectively) because the most</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        accurate change in position comes from computing the average</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        velocity during dt1. We separate the two position changes, dx and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddx0, because dx will be unchanged when we do the predictor-corrector</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        below (the change in position due to the original speed is always</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        there), while ddx0 will be modified when ax0 and hence dv is modified</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        by the predictor-corrector.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        - Finally, set ddx1 and ddy1 to ddx0 and ddy0 initially. They will</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        change when we enter the predictor-corrector code.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dv = ax0*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        du = ay0*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dx = v*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dy = u*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddx0 = dv/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddy0 = du/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddx1 = ddx0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddy1 = ddy0;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Now advance the position of the satellite by our initial estimates of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the position changes, dx + ddx0 and dy + ddy0. Compute the radial</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        distance of this new position and the acceleration there.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        x1 = x0 + dx + ddx0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        y1 = y0 + dy + ddy0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        r = Math.sqrt( x1*x1 + y1*y1 );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        r3 = r*r*r;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ax1 = -kGravity*x1/r3;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ay1 = -kGravity*y1/r3;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Time-step check.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        This is the code to check whether the time-step is too large. The idea</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        is to compare the changes in acceleration during the timestep with the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        acceleration itself. If the change is too large a fraction of the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        original value, then the step is likely to be too large, and the
        resulting</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        position too inaccurate. The code below cuts the time-step dt1 in half</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        and then goes back to the beginning of the loop. This is explained
        below.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        But first we explain the test itself.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        There is no unique test for this, nor does there need to be. If the
        time-step</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        is cut in half the calculation will be more accurate, so generally in</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        a test like this one tries to formulate the test just to make sure that</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        some kind of inaccuracy is being measured. Here the test is to compute</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the absolute value of the change in the x-acceleration, ax1-ax0, and add</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        that to the absolute value of the change in the y-acceleration, ay1-ay0,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        to get a measure of how big the change in acceleration is. This is then</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        compared with the "original" acceleration, which is similarly measured</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        by the sum of the absolute values of the components of the acceleration</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        at the start of the time-steps, |ax0| + |ay0|. The comparison is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        simple: the user chooses the small number eps1, and if the changes</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        are larger than eps1 times the original, then the time-step is changed.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        The test has the form of the logical comparison</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        change &gt; eps * original</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        where "change" and "original" are computed as above.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        The action that is taken is simple:</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        - If the changes are too large, the time-step is cut in half (dt1 /= 2)</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        and the loop index j is decreased by 1 (j--). Nothing else happens after</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        this point in the loop: the rest of the code after this is inside the
        "else"</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        clause that is executed if the change is small enough. So this pass</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        through the loop ends after the statement "j--;". The reason for</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        decreasing j is that the "for" statement automatically increases</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        j each time, but we want j to remain the same, since we are re-doing</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the same time-step with a smaller value of dt1.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        - If the changes are sufficiently small, the "else" clause is executed</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        instead. This keeps the value of dt1 the same. The "else" clause</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        contains the predictor-corrector step that is described in the comments</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        below.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if ( Math.abs(ax1-ax0) + Math.abs(ay1-ay0) &gt; eps1*(Math.abs(ax0) +
        Math.abs(ay0))
        ){</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dt1 /= 2;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        j--;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else {</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Predictor-corrector step.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Now that the time-step dt1 is fixed, we address the other new feature</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        of this program, which is to ensure that the position changes are</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        computed using the average velocity over the time dt1. This in turn</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        requires us to calculate the velocity change, also by averaging the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        acceleration. But the acceleration is a function of position, so we</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        do not know how to average it until we find the final position. This</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        is a circular requirement, and cannot be solved in a single step.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        However, it can be solved iteratively. That is, one can make a guess</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        and keep refining it.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        The initial guess has already been made: we have computed values of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dx, dy, ddx0, and ddy0 from the data available at the beginning of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the current time-step. Recall that dx and dy depend only on the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        velocity at the beginning of the time-step, but ddx0 and ddy0 depend</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        on the acceleration. So we will refine them, computing replacement</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        values ddx1 and ddy1 as we get better values for the acceleration at</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the end of the time-step. The refinement is done in another loop, whose</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        counter is k below. Before enetering the loop, we define a</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        variable called testPrediction which stores a measure of how large</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the initial guesses are, so that we can stop the iteration when the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        refined values do not change by much.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        The for loop is limited to at most 10 iterations. This is to prevent</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        it from getting stuck for some reason and never finishing. Ten</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        iterations should be sufficient for any reasonable problem.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        testPrediction = Math.abs(ddx0) + Math.abs(ddy0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        for ( k = 0; k &lt; 10; k++ ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        /* compute dv and du by averaging the acceleration over dt1 */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        dv = (ax0 + ax1)/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        du = (ay0 + ay1)/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        /* compute ddx1 and ddy1 by averaging the velocity change */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddx1 = dv/2*dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddy1 = du/2*dt1;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Test the change in ddx and ddy since the last iteration.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        If it is more than a fraction eps2 of the original, then</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddx and ddy have to be re-computed by finding the acceleration</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        at the refined position.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        If the change is small enough, then the "else:" clause is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        executed, which exits from the for loop using the statement</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        "break". This finishes the iteration and goes on to wrap up</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the calculation.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if ( Math.abs(ddx1-ddx0) + Math.abs(ddy1-ddy0) &gt; eps2 *
        testPrediction
        ) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        /* Re-define ddx0 and ddy0 to hold the values from the last iteration */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddx0 = ddx1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddy0 = ddy1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        x1 = x0 + dx + ddx0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        y1 = y0 + dx + ddy0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        r = Math.sqrt( x1*x1 + y1*y1 );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        r3 = r*r*r;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ax1 = -kGravity*x1/r3;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ay1 = -kGravity*y1/r3;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        We now have the "best" acceleration values, using the most</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        recent estimates of the position at the end of the loop.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        The next statement to be executed will be the first statement</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        of the "for" loop, finding better values of dv, du, ddx1, and</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ddy1.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else break;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        The iteration has finished, and we have sufficiently accurate</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        values of the position change in ddx1 and ddy1. Use them to get</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        final values of x and y at the end of the time-step dt1 and store</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        these into x0 and y0, ready for the next time-step. Compute all</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the rest of the variables needed for the next time-step and for</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        possible data output.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        t += dt1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        x0 += dx + ddx1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        y0 += dy + ddy1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ax0 = ax1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        ay0 = ay1;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        v += dv;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        u += du;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xCoordinate[j] = x0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yCoordinate[j] = y0;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        xVelocity[j] = v;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        yVelocity[j] = u;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        r = Math.sqrt( x0*x0 + y0*y0 );</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        potentialEnergy[j] = -kGravity/r;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        kineticEnergy[j] = 0.5*(v*v + u*u);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        time[j] = t;</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    /*</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        Now test to see if the orbit has closed, i.e. if we have gone around</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the central mass once. We do this by computing the change in the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        angular position of the orbit from its starting position, using the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        same code for keeping the angular difference between -Pi and +Pi as</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        we used at the beginning of the program. This is stored in anglediff</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        as before. Once anglediff has been calculated, we enter the code</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        that tests for the completion of the orbit. It is based on an "if"</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        statement. The first part of the statement is executed if !halfOrbit is</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        "true", i.e. if at the previous step we were not yet half-way around</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        the central mass. The purpose of this part is to test the value of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        anglediff to see if we have gone half-way by the present step. The</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        test depends on whether the orbit goes counterclockwise or not, so</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        this part of the overall "if" statement contains another "if". If</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        we are going counterclockwise, then in previous steps the value of</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        anglediff has been increasing. When it reaches Pi, we are half-way. It</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        will never exactly equal Pi, since our steps are not chosen to make</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        an integer number of divisions of the orbit, so we recognize that we</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        have gone half-way by allowing anglediff to get larger than Pi.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        However, we know from the previous lines of code that when anglediff</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        is larger than Pi, we subtract 2*Pi, and therefore it becomes</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        negative. This is therefore the test: if anglediff is negative, we</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        know we have gone half-way, and we set the value of halfOrbit to true.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        If the orbit were a clockwise orbit, then this is reversed: the</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        first time anglediff goes positive, we set halfOrbit to true.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        If, however, we have already gone half-way by the time of the present</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        time-step, then the "else" clause of the overall "if" statement</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        will execute. This looks for the end of the orbit with the opposite</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        criterion to finding the half-way point. For a counterclockwise orbit,</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        when anglediff becomes positive again, we have passed through orbital</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        difference zero, which is where we started, so the orbit has finished.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        In the clockwise case, we watch anglediff to see when it goes</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        negative. This finishes the orbit. We set the value of fullOrbit</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        to "true". This causes the overall loop around the orbit to finish.</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        */</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        angleNow = Math.atan2(y0, x0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        anglediff = angleNow - angleInitPos;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if (anglediff &gt; Math.PI) anglediff -= 2*Math.PI;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else if (anglediff &lt; -Math.PI) anglediff += 2*Math.PI;</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if (!halfOrbit) {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if (counterclockwise) halfOrbit = (anglediff &lt; 0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else halfOrbit = (anglediff &gt; 0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else {</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        if ( counterclockwise ) fullOrbit = (anglediff &gt; 0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        else fullOrbit = (anglediff &lt; 0);</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        }</tt>
    <br>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The orbit
    is finished. Now, as in previous programs, define arrays</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to contain
    the positions along the orbit with just the right size,</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; so that
    no zeros are passed to the grapher. The value of j at this</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point is
    equal to the number of elements we need for the output arrays.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; But in this
    program, we must also check which output choice has been made and</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tailor the
    output to this choice. This includes, for some choices, multiple</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output
    nodes,
    as in EarthOrbit. First-time programmers can safely</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ignore this
    section.</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br>
<tt>&nbsp;</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if
    (outputType.equals("orbit
    (X,Y)")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalX = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalY = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalX[k] = xCoordinate[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalY[k] = yCoordinate[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out = new Curve( finalX, finalY );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out.setTitle("Velocity of orbit");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out.setIndependentLabels(0,"x (m)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out.setDependentLabels(0,"y (m)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    output( out );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
    (outputType.equals("velocity
    space (V,U)")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalV = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalU = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalV[k] = xVelocity[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalU[k] = yVelocity[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out = new Curve( finalV, finalU );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out.setTitle("Velocity of orbit");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out.setIndependentLabels(0,"V (m/s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out.setDependentLabels(0,"U (m/s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    output( out );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
    (outputType.equals("position
    vs. time (X,t) and (Y,t)")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalX = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalY = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalT = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalX[k] = xCoordinate[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalY[k] = yCoordinate[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalT[k] = time[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out0 = new Curve( finalT, finalX );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setTitle("x(t)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setIndependentLabels(0,"t (s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setDependentLabels(0,"position (m)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out1 = new Curve( finalT, finalY );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out1.setTitle("y(t)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 0, out0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 1, out1 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
    (outputType.equals("velocity
    vs. time (V,t) and (U,t)")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalV = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalU = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalT = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalV[k] = xVelocity[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalU[k] = yVelocity[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalT[k] = time[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out0 = new Curve( finalT, finalV );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setTitle("V(t)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setIndependentLabels(0,"t (s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setDependentLabels(0,"speed (m)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out1 = new Curve( finalT, finalU );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out1.setTitle("U(t)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 0, out0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 1, out1 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if
    (outputType.equals("energy
    vs time")) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalP = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalK = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalE = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    double[] finalT = new double[j];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    for ( k = 0; k &lt; j; k++ ) {</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalP[k] = potentialEnergy[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalK[k] = kineticEnergy[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalE[k] = finalP[k] + finalK[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    finalT[k] = time[k];</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    }</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out0 = new Curve( finalT, finalP );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setTitle("Potential energy vs time");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setIndependentLabels(0,"t (s)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out0.setDependentLabels(0,"energy (J)");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out1 = new Curve( finalT, finalK );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out1.setTitle("Kinetic energy vs time");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    Curve out2 = new Curve( finalT, finalE );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    out2.setTitle("Total energy vs time");</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 0, out0 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 1, out1 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    outputAtNode( 2, out2 );</tt>
<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
</p>

<p><tt>&nbsp;&nbsp;&nbsp; }</tt>
    <br>
    &nbsp;
    <br>
    &nbsp;
</p>

<p></p>
<hr width="15%" size="4">
<br>
<b><font size="-1">Return to <a href="index.html">index</a> of all
    computer
    programs.</font></b>
</body>
</html>
