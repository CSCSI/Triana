package signalproc.algorithms;

/**
 * FFTLibrary.java
 * <p/>
 * <p/>
 * The Real data is generated by the in-phase (I) channel, and the Imaginary data is produced by the quadrature-phase
 * (Q) channel of a Doppler Radar receiver.  The middle filter is zero Hz.  Closing targets are displayed to the right,
 * and Opening targets to the left.
 * <p/>
 * Note: With Imaginary data set to zero the output is a mirror image. )
 */

class FFTLibrary {
    /*
      * Precalculated values
      */
    public double SampleRate;    // sample rate for displaying
    public int NSamples;        // must be a power of 2
    public int Power;        // log2 of NSamples
    private int[] Permute;    // bit reversing permutation table
    private double[] Sines;    // pre-computed table of sines

    /*
      * Temporary values
      */
    public double[] Real;    // Temporary: Real part
    public double[] Imag;    // Temporary: Imaginary part
    public double[] real;
    public double[] imag;

    /**
     * Initialization routine precalculates information in order to speed up subsequent FFT calculations.
     *
     * @param rate     Sample rate of input data
     * @param nsamples Number of samples to FFT at a time. Must be a power of two.
     */
    public FFTLibrary(double rate, int nsamples) throws Exception {
        SampleRate = rate;
        NSamples = nsamples;

        // Input data array length must be a power of two
        Power = (int) (Math.log((double) NSamples) / Math.log(2.0));

        if ((1 << Power) != NSamples) {
            throw new Exception();
        }

        /*
         * Build table of sines.  The table is a sampling of sin(x)
         * for x = 0 to 2pi step d, where d is 2pi/N.  N is the
         * total number of samples.
         */
        Sines = new double[NSamples];
        for (int i = 0; i < Sines.length; i++) {
            Sines[i] = (double)
                    Math.sin((double) (i * (2 * Math.PI) / Sines.length));
        }

        // Build the bit reversal lookup table
        Permute = new int[NSamples];
        int result;
        for (int index = 0; index < NSamples; index++) {
            result = 0;
            for (int loop = 0; loop < Power; loop++) {
                if ((index & (1 << loop)) != 0) {
                    result |= 1 << (Power - 1 - loop);
                }
            }
            Permute[index] = result;
        }
    }

    public void calculate(double[] rdata, double[] idata, boolean direct) {
        /*
         * If a direct FFT, scale the data; if inverse FFT, do not scale
         */
        // A place to hold the data
        Real = new double[NSamples];
        Imag = new double[NSamples];

        real = new double[NSamples];
        imag = new double[NSamples];

        if (direct)
        // Scale input data
        {
            for (int i = 0; i < rdata.length; ++i) {
                Real[i] = (double) rdata[i] / (double) NSamples;
                Imag[i] = (double) idata[i] / (double) NSamples;
            }
        } else {
            // Don't scale input data
            Real = rdata;
            Imag = idata;
        }

        runfft();
    }

    public void calculate(double[] rdata, boolean direct) {
        /*
         * If a direct FFT, scale the data; if an inverse FFT, do not scale.
	 * In each case, assume the imaginary part of the input data is zero.
         */
        // A place to hold the data
        Real = new double[NSamples];
        Imag = new double[NSamples];

        real = new double[NSamples / 2];
        imag = new double[NSamples / 2];

        if (direct)
        // Scale input data
        {
            for (int i = 0; i < rdata.length; ++i) {
                Real[i] = (double) rdata[i] / (double) NSamples;
                Imag[i] = 0.0;
            }
        } else
        // Don't scale input data
        {
            for (int i = 0; i < rdata.length; ++i) {
                Real[i] = (double) rdata[i];
                Imag[i] = 0.0;
            }
        }

        runfft();
    }

    private void runfft() {
        // begin FFT
        int i1 = NSamples / 2;
        int i2 = 1;
        double a1;
        double a2;
        double b1;
        double b2;

        /* perform the butterfly's */

        for (int loop = 0; loop < Power; loop++) {
            int i3 = 0;
            int i4 = i1;
            int y;
            double z1;
            double z2;

            for (int loop1 = 0; loop1 < i2; loop1++) {
                y = Permute[i3 / i1];
                z1 = Sines[((y) + (Real.length >> 2)) % Real.length]; // cosine
                z2 = -Sines[y];

                for (int loop2 = i3; loop2 < i4; loop2++) {
                    a1 = Real[loop2];
                    a2 = Imag[loop2];

                    b1 = z1 * Real[loop2 + i1] - z2 * Imag[loop2 + i1];
                    b2 = z2 * Real[loop2 + i1] + z1 * Imag[loop2 + i1];

                    Real[loop2] = a1 + b1;
                    Imag[loop2] = a2 + b2;

                    Real[loop2 + i1] = a1 - b1;
                    Imag[loop2 + i1] = a2 - b2;
                }

                i3 += (i1 << 1);
                i4 += (i1 << 1);
            }

            i1 >>= 1;
            i2 <<= 1;
        }
        // end of FFT
        // juggle them back again :-
        int p;
        for (int i = 0; i < real.length; i++) {
            p = Permute[i];
            real[i] = Real[p];
            imag[i] = Imag[p];
        }
    }
}













